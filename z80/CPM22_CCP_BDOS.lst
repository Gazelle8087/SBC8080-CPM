 AS V1.42 Beta [Bld 271] - Source File CPM22_CCP_BDOS.asm - Page 1 - 7/13/2024 12:6:36


    1/   0 :                            
    2/   0 :                            ;**************************************************************
    3/   0 :                            ;*
    4/   0 :                            ;*             C P / M   version   2 . 2
    5/   0 :                            ;*
    6/   0 :                            ;*   Reconstructed from memory image on February 27, 1981
    7/   0 :                            ;*
    8/   0 :                            ;*                by Clark A. Calkins
    9/   0 :                            ;*
   10/   0 :                            ;**************************************************************
   11/   0 :                            ;
   12/   0 :                            ;   Set memory limit here. This is the amount of contigeous
   13/   0 :                            ; ram starting from 0000. CP/M will reside at the end of this space.
   14/   0 :                            ;
   15/   0 :                            	PAGE	0
   16/   0 :                            	CPU	8080
   17/   0 : =40H                       MEM	EQU	64	;for a 62k system (TS802 TEST - WORKS OK).
   18/   0 :                            ;
   19/   0 : =3H                        IOBYTE	EQU	3	;i/o definition byte.
   20/   0 : =4H                        TDRIVE	EQU	4	;current drive name and user number.
   21/   0 : =5H                        ENTRY	EQU	5	;entry point for the cp/m bdos.
   22/   0 : =5CH                       TFCB	EQU	5CH	;default file control block.
   23/   0 : =80H                       TBUFF	EQU	80H	;i/o buffer and command line storage.
   24/   0 : =100H                      TBASE	EQU	100H	;transiant program storage area.
   25/   0 :                            ;
   26/   0 :                            ;   Set control character equates.
   27/   0 :                            ;
   28/   0 : =3H                        CNTRLC	EQU	3	;control-c
   29/   0 : =5H                        CNTRLE	EQU	05H	;control-e
   30/   0 : =8H                        BS	EQU	08H	;backspace
   31/   0 : =9H                        TAB	EQU	09H	;tab
   32/   0 : =0AH                       LF	EQU	0AH	;line feed
   33/   0 : =0CH                       FF	EQU	0CH	;form feed
   34/   0 : =0DH                       CR	EQU	0DH	;carriage return
   35/   0 : =10H                       CNTRLP	EQU	10H	;control-p
   36/   0 : =12H                       CNTRLR	EQU	12H	;control-r
   37/   0 : =13H                       CNTRLS	EQU	13H	;control-s
   38/   0 : =15H                       CNTRLU	EQU	15H	;control-u
   39/   0 : =18H                       CNTRLX	EQU	18H	;control-x
   40/   0 : =1AH                       CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
   41/   0 : =7FH                       DEL	EQU	7FH	;rubout
   42/   0 :                            ;
   43/   0 :                            ;   Set origin for CP/M
   44/   0 :                            ;
   45/E400 :                            	ORG	(MEM-7)*1024
   46/E400 :                            ;
   47/E400 : C3 5C E7                   CBASE	JMP	COMMAND	;execute command processor (ccp).
   48/E403 : C3 58 E7                   	JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
   49/E406 :                            
   50/E406 :                            ;
   51/E406 :                            ;   Standard cp/m ccp input buffer. Format is (max length),
   52/E406 :                            ; (actual length), (char #1), (char #2), (char #3), etc.
   53/E406 :                            ;
   54/E406 : 7F                         INBUFF	DB	127	;length of input buffer.
   55/E407 : 00                         	DB	0	;current length of contents.
   56/E408 : 43 6F 70 79 72 69 67 68 74 	DB	'Copyright'
   57/E411 : 20 31 39 37 39 20 28 63 29 	DB	' 1979 (c) by Digital Research      '
      E41A : 20 62 79 20 44 69 67 69 74
      E423 : 61 6C 20 52 65 73 65 61 72
      E42C : 63 68 20 20 20 20 20 20   
   58/E434 : 00 00 00 00 00 00 00 00 00 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      E43D : 00 00 00 00 00 00 00 00 00
      E446 : 00 00 00 00 00            
   59/E44B : 00 00 00 00 00 00 00 00 00 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      E454 : 00 00 00 00 00 00 00 00 00
      E45D : 00 00 00 00 00            
   60/E462 : 00 00 00 00 00 00 00 00 00 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      E46B : 00 00 00 00 00 00 00 00 00
      E474 : 00 00 00 00 00            
   61/E479 : 00 00 00 00 00 00 00 00 00 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      E482 : 00 00 00 00 00 00         
   62/E488 : 08 E4                      INPOINT	DW	INBUFF+2;input line pointer
   63/E48A : 00 00                      NAMEPNT	DW	0	;input line pointer used for error message. Points to
   64/E48C :                            ;			;start of name in error.
   65/E48C :                            ;
   66/E48C :                            ;   Routine to print (A) on the console. All registers used.
   67/E48C :                            ;
   68/E48C : 5F                         PRINT	MOV	E,A	;setup bdos call.
   69/E48D : 0E 02                      	MVI	C,2
   70/E48F : C3 05 00                   	JMP	ENTRY
   71/E492 :                            ;
   72/E492 :                            ;   Routine to print (A) on the console and to save (BC).
   73/E492 :                            ;
   74/E492 : C5                         PRINTB	PUSH	B
   75/E493 : CD 8C E4                   	CALL	PRINT
   76/E496 : C1                         	POP	B
   77/E497 : C9                         	RET
   78/E498 :                            ;
   79/E498 :                            ;   Routine to send a carriage return, line feed combination
   80/E498 :                            ; to the console.
   81/E498 :                            ;
   82/E498 : 3E 0D                      CRLF	MVI	A,CR
   83/E49A : CD 92 E4                   	CALL	PRINTB
   84/E49D : 3E 0A                      	MVI	A,LF
   85/E49F : C3 92 E4                   	JMP	PRINTB
   86/E4A2 :                            ;
   87/E4A2 :                            ;   Routine to send one space to the console and save (BC).
   88/E4A2 :                            ;
   89/E4A2 : 3E 20                      SPACE	MVI	A,' '
   90/E4A4 : C3 92 E4                   	JMP	PRINTB
   91/E4A7 :                            ;
   92/E4A7 :                            ;   Routine to print character string pointed to be (BC) on the
   93/E4A7 :                            ; console. It must terminate with a null byte.
   94/E4A7 :                            ;
   95/E4A7 : C5                         PLINE	PUSH	B
   96/E4A8 : CD 98 E4                   	CALL	CRLF
   97/E4AB : E1                         	POP	H
   98/E4AC : 7E                         PLINE2	MOV	A,M
   99/E4AD : B7                         	ORA	A
  100/E4AE : C8                         	RZ
  101/E4AF : 23                         	INX	H
  102/E4B0 : E5                         	PUSH	H
  103/E4B1 : CD 8C E4                   	CALL	PRINT
  104/E4B4 : E1                         	POP	H
  105/E4B5 : C3 AC E4                   	JMP	PLINE2
  106/E4B8 :                            ;
  107/E4B8 :                            ;   Routine to reset the disk system.
  108/E4B8 :                            ;
  109/E4B8 : 0E 0D                      RESDSK	MVI	C,13
  110/E4BA : C3 05 00                   	JMP	ENTRY
  111/E4BD :                            ;
  112/E4BD :                            ;   Routine to select disk (A).
  113/E4BD :                            ;
  114/E4BD : 5F                         DSKSEL	MOV	E,A
  115/E4BE : 0E 0E                      	MVI	C,14
  116/E4C0 : C3 05 00                   	JMP	ENTRY
  117/E4C3 :                            ;
  118/E4C3 :                            ;   Routine to call bdos and save the return code. The zero
  119/E4C3 :                            ; flag is set on a return of 0ffh.
  120/E4C3 :                            ;
  121/E4C3 : CD 05 00                   ENTRY1	CALL	ENTRY
  122/E4C6 : 32 EE EB                   	STA	RTNCODE	;save return code.
  123/E4C9 : 3C                         	INR	A	;set zero if 0ffh returned.
  124/E4CA : C9                         	RET
  125/E4CB :                            ;
  126/E4CB :                            ;   Routine to open a file. (DE) must point to the FCB.
  127/E4CB :                            ;
  128/E4CB : 0E 0F                      OPEN	MVI	C,15
  129/E4CD : C3 C3 E4                   	JMP	ENTRY1
  130/E4D0 :                            ;
  131/E4D0 :                            ;   Routine to open file at (FCB).
  132/E4D0 :                            ;
  133/E4D0 : AF                         OPENFCB	XRA	A	;clear the record number byte at fcb+32
  134/E4D1 : 32 ED EB                   	STA	FCB+32
  135/E4D4 : 11 CD EB                   	LXI	D,FCB
  136/E4D7 : C3 CB E4                   	JMP	OPEN
  137/E4DA :                            ;
  138/E4DA :                            ;   Routine to close a file. (DE) points to FCB.
  139/E4DA :                            ;
  140/E4DA : 0E 10                      CLOSE	MVI	C,16
  141/E4DC : C3 C3 E4                   	JMP	ENTRY1
  142/E4DF :                            ;
  143/E4DF :                            ;   Routine to search for the first file with ambigueous name
  144/E4DF :                            ; (DE).
  145/E4DF :                            ;
  146/E4DF : 0E 11                      SRCHFST	MVI	C,17
  147/E4E1 : C3 C3 E4                   	JMP	ENTRY1
  148/E4E4 :                            ;
  149/E4E4 :                            ;   Search for the next ambigeous file name.
  150/E4E4 :                            ;
  151/E4E4 : 0E 12                      SRCHNXT	MVI	C,18
  152/E4E6 : C3 C3 E4                   	JMP	ENTRY1
  153/E4E9 :                            ;
  154/E4E9 :                            ;   Search for file at (FCB).
  155/E4E9 :                            ;
  156/E4E9 : 11 CD EB                   SRCHFCB	LXI	D,FCB
  157/E4EC : C3 DF E4                   	JMP	SRCHFST
  158/E4EF :                            ;
  159/E4EF :                            ;   Routine to delete a file pointed to by (DE).
  160/E4EF :                            ;
  161/E4EF : 0E 13                      DELETE	MVI	C,19
  162/E4F1 : C3 05 00                   	JMP	ENTRY
  163/E4F4 :                            ;
  164/E4F4 :                            ;   Routine to call the bdos and set the zero flag if a zero
  165/E4F4 :                            ; status is returned.
  166/E4F4 :                            ;
  167/E4F4 : CD 05 00                   ENTRY2	CALL	ENTRY
  168/E4F7 : B7                         	ORA	A	;set zero flag if appropriate.
  169/E4F8 : C9                         	RET
  170/E4F9 :                            ;
  171/E4F9 :                            ;   Routine to read the next record from a sequential file.
  172/E4F9 :                            ; (DE) points to the FCB.
  173/E4F9 :                            ;
  174/E4F9 : 0E 14                      RDREC	MVI	C,20
  175/E4FB : C3 F4 E4                   	JMP	ENTRY2
  176/E4FE :                            ;
  177/E4FE :                            ;   Routine to read file at (FCB).
  178/E4FE :                            ;
  179/E4FE : 11 CD EB                   READFCB	LXI	D,FCB
  180/E501 : C3 F9 E4                   	JMP	RDREC
  181/E504 :                            ;
  182/E504 :                            ;   Routine to write the next record of a sequential file.
  183/E504 :                            ; (DE) points to the FCB.
  184/E504 :                            ;
  185/E504 : 0E 15                      WRTREC	MVI	C,21
  186/E506 : C3 F4 E4                   	JMP	ENTRY2
  187/E509 :                            ;
  188/E509 :                            ;   Routine to create the file pointed to by (DE).
  189/E509 :                            ;
  190/E509 : 0E 16                      CREATE	MVI	C,22
  191/E50B : C3 C3 E4                   	JMP	ENTRY1
  192/E50E :                            ;
  193/E50E :                            ;   Routine to rename the file pointed to by (DE). Note that
  194/E50E :                            ; the new name starts at (DE+16).
  195/E50E :                            ;
  196/E50E : 0E 17                      RENAM	MVI	C,23
  197/E510 : C3 05 00                   	JMP	ENTRY
  198/E513 :                            ;
  199/E513 :                            ;   Get the current user code.
  200/E513 :                            ;
  201/E513 : 1E FF                      GETUSR	MVI	E,0FFH
  202/E515 :                            ;
  203/E515 :                            ;   Routne to get or set the current user code.
  204/E515 :                            ; If (E) is FF then this is a GET, else it is a SET.
  205/E515 :                            ;
  206/E515 : 0E 20                      GETSETUC:MVI	C,32
  207/E517 : C3 05 00                   	JMP	ENTRY
  208/E51A :                            ;
  209/E51A :                            ;   Routine to set the current drive byte at (TDRIVE).
  210/E51A :                            ;
  211/E51A : CD 13 E5                   SETCDRV	CALL	GETUSR	;get user number
  212/E51D : 87                         	ADD	A	;and shift into the upper 4 bits.
  213/E51E : 87                         	ADD	A
  214/E51F : 87                         	ADD	A
  215/E520 : 87                         	ADD	A
  216/E521 : 21 EF EB                   	LXI	H,CDRIVE;now add in the current drive number.
  217/E524 : B6                         	ORA	M
  218/E525 : 32 04 00                   	STA	TDRIVE	;and save.
  219/E528 : C9                         	RET
  220/E529 :                            ;
  221/E529 :                            ;   Move currently active drive down to (TDRIVE).
  222/E529 :                            ;
  223/E529 : 3A EF EB                   MOVECD	LDA	CDRIVE
  224/E52C : 32 04 00                   	STA	TDRIVE
  225/E52F : C9                         	RET
  226/E530 :                            ;
  227/E530 :                            ;   Routine to convert (A) into upper case ascii. Only letters
  228/E530 :                            ; are affected.
  229/E530 :                            ;
  230/E530 : FE 61                      UPPER	CPI	'a'	;check for letters in the range of 'a' to 'z'.
  231/E532 : D8                         	RC
  232/E533 : FE 7B                      	CPI	'{'
  233/E535 : D0                         	RNC
  234/E536 : E6 5F                      	ANI	5FH	;convert it if found.
  235/E538 : C9                         	RET
  236/E539 :                            ;
  237/E539 :                            ;   Routine to get a line of input. We must check to see if the
  238/E539 :                            ; user is in (BATCH) mode. If so, then read the input from file
  239/E539 :                            ; ($$$.SUB). At the end, reset to console input.
  240/E539 :                            ;
  241/E539 : 3A AB EB                   GETINP	LDA	BATCH	;if =0, then use console input.
  242/E53C : B7                         	ORA	A
  243/E53D : CA 96 E5                   	JZ	GETINP1
  244/E540 :                            ;
  245/E540 :                            ;   Use the submit file ($$$.sub) which is prepared by a
  246/E540 :                            ; SUBMIT run. It must be on drive (A) and it will be deleted
  247/E540 :                            ; if and error occures (like eof).
  248/E540 :                            ;
  249/E540 : 3A EF EB                   	LDA	CDRIVE	;select drive 0 if need be.
  250/E543 : B7                         	ORA	A
  251/E544 : 3E 00                      	MVI	A,0	;always use drive A for submit.
  252/E546 : C4 BD E4                   	CNZ	DSKSEL	;select it if required.
  253/E549 : 11 AC EB                   	LXI	D,BATCHFCB
  254/E54C : CD CB E4                   	CALL	OPEN	;look for it.
  255/E54F : CA 96 E5                   	JZ	GETINP1	;if not there, use normal input.
  256/E552 : 3A BB EB                   	LDA	BATCHFCB+15;get last record number+1.
  257/E555 : 3D                         	DCR	A
  258/E556 : 32 CC EB                   	STA	BATCHFCB+32
  259/E559 : 11 AC EB                   	LXI	D,BATCHFCB
  260/E55C : CD F9 E4                   	CALL	RDREC	;read last record.
  261/E55F : C2 96 E5                   	JNZ	GETINP1	;quit on end of file.
  262/E562 :                            ;
  263/E562 :                            ;   Move this record into input buffer.
  264/E562 :                            ;
  265/E562 : 11 07 E4                   	LXI	D,INBUFF+1
  266/E565 : 21 80 00                   	LXI	H,TBUFF	;data was read into buffer here.
  267/E568 : 06 80                      	MVI	B,128	;all 128 characters may be used.
  268/E56A : CD 42 E8                   	CALL	HL2DE	;(HL) to (DE), (B) bytes.
  269/E56D : 21 BA EB                   	LXI	H,BATCHFCB+14
  270/E570 : 36 00                      	MVI	M,0	;zero out the 's2' byte.
  271/E572 : 23                         	INX	H	;and decrement the record count.
  272/E573 : 35                         	DCR	M
  273/E574 : 11 AC EB                   	LXI	D,BATCHFCB;close the batch file now.
  274/E577 : CD DA E4                   	CALL	CLOSE
  275/E57A : CA 96 E5                   	JZ	GETINP1	;quit on an error.
  276/E57D : 3A EF EB                   	LDA	CDRIVE	;re-select previous drive if need be.
  277/E580 : B7                         	ORA	A
  278/E581 : C4 BD E4                   	CNZ	DSKSEL	;don't do needless selects.
  279/E584 :                            ;
  280/E584 :                            ;   Print line just read on console.
  281/E584 :                            ;
  282/E584 : 21 08 E4                   	LXI	H,INBUFF+2
  283/E587 : CD AC E4                   	CALL	PLINE2
  284/E58A : CD C2 E5                   	CALL	CHKCON	;check console, quit on a key.
  285/E58D : CA A7 E5                   	JZ	GETINP2	;jump if no key is pressed.
  286/E590 :                            ;
  287/E590 :                            ;   Terminate the submit job on any keyboard input. Delete this
  288/E590 :                            ; file such that it is not re-started and jump to normal keyboard
  289/E590 :                            ; input section.
  290/E590 :                            ;
  291/E590 : CD DD E5                   	CALL	DELBATCH;delete the batch file.
  292/E593 : C3 82 E7                   	JMP	CMMND1	;and restart command input.
  293/E596 :                            ;
  294/E596 :                            ;   Get here for normal keyboard input. Delete the submit file
  295/E596 :                            ; incase there was one.
  296/E596 :                            ;
  297/E596 : CD DD E5                   GETINP1	CALL	DELBATCH;delete file ($$$.sub).
  298/E599 : CD 1A E5                   	CALL	SETCDRV	;reset active disk.
  299/E59C : 0E 0A                      	MVI	C,10	;get line from console device.
  300/E59E : 11 06 E4                   	LXI	D,INBUFF
  301/E5A1 : CD 05 00                   	CALL	ENTRY
  302/E5A4 : CD 29 E5                   	CALL	MOVECD	;reset current drive (again).
  303/E5A7 :                            ;
  304/E5A7 :                            ;   Convert input line to upper case.
  305/E5A7 :                            ;
  306/E5A7 : 21 07 E4                   GETINP2	LXI	H,INBUFF+1
  307/E5AA : 46                         	MOV	B,M	;(B)=character counter.
  308/E5AB : 23                         GETINP3	INX	H
  309/E5AC : 78                         	MOV	A,B	;end of the line?
  310/E5AD : B7                         	ORA	A
  311/E5AE : CA BA E5                   	JZ	GETINP4
  312/E5B1 : 7E                         	MOV	A,M	;convert to upper case.
  313/E5B2 : CD 30 E5                   	CALL	UPPER
  314/E5B5 : 77                         	MOV	M,A
  315/E5B6 : 05                         	DCR	B	;adjust character count.
  316/E5B7 : C3 AB E5                   	JMP	GETINP3
  317/E5BA : 77                         GETINP4	MOV	M,A	;add trailing null.
  318/E5BB : 21 08 E4                   	LXI	H,INBUFF+2
  319/E5BE : 22 88 E4                   	SHLD	INPOINT	;reset input line pointer.
  320/E5C1 : C9                         	RET
  321/E5C2 :                            ;
  322/E5C2 :                            ;   Routine to check the console for a key pressed. The zero
  323/E5C2 :                            ; flag is set is none, else the character is returned in (A).
  324/E5C2 :                            ;
  325/E5C2 : 0E 0B                      CHKCON	MVI	C,11	;check console.
  326/E5C4 : CD 05 00                   	CALL	ENTRY
  327/E5C7 : B7                         	ORA	A
  328/E5C8 : C8                         	RZ		;return if nothing.
  329/E5C9 : 0E 01                      	MVI	C,1	;else get character.
  330/E5CB : CD 05 00                   	CALL	ENTRY
  331/E5CE : B7                         	ORA	A	;clear zero flag and return.
  332/E5CF : C9                         	RET
  333/E5D0 :                            ;
  334/E5D0 :                            ;   Routine to get the currently active drive number.
  335/E5D0 :                            ;
  336/E5D0 : 0E 19                      GETDSK	MVI	C,25
  337/E5D2 : C3 05 00                   	JMP	ENTRY
  338/E5D5 :                            ;
  339/E5D5 :                            ;   Set the stabdard dma address.
  340/E5D5 :                            ;
  341/E5D5 : 11 80 00                   STDDMA	LXI	D,TBUFF
  342/E5D8 :                            ;
  343/E5D8 :                            ;   Routine to set the dma address to (DE).
  344/E5D8 :                            ;
  345/E5D8 : 0E 1A                      DMASET	MVI	C,26
  346/E5DA : C3 05 00                   	JMP	ENTRY
  347/E5DD :                            ;
  348/E5DD :                            ;  Delete the batch file created by SUBMIT.
  349/E5DD :                            ;
  350/E5DD : 21 AB EB                   DELBATCH:LXI	H,BATCH	;is batch active?
  351/E5E0 : 7E                         	MOV	A,M
  352/E5E1 : B7                         	ORA	A
  353/E5E2 : C8                         	RZ
  354/E5E3 : 36 00                      	MVI	M,0	;yes, de-activate it.
  355/E5E5 : AF                         	XRA	A
  356/E5E6 : CD BD E4                   	CALL	DSKSEL	;select drive 0 for sure.
  357/E5E9 : 11 AC EB                   	LXI	D,BATCHFCB;and delete this file.
  358/E5EC : CD EF E4                   	CALL	DELETE
  359/E5EF : 3A EF EB                   	LDA	CDRIVE	;reset current drive.
  360/E5F2 : C3 BD E4                   	JMP	DSKSEL
  361/E5F5 :                            ;
  362/E5F5 :                            ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
  363/E5F5 :                            ; the same or we halt....
  364/E5F5 :                            ;
  365/E5F5 : 11 28 E7                   VERIFY	LXI	D,PATTRN1;these are the serial number bytes.
  366/E5F8 : 21 00 EC                   	LXI	H,PATTRN2;ditto, but how could they be different?
  367/E5FB : 06 06                      	MVI	B,6	;6 bytes each.
  368/E5FD : 1A                         VERIFY1	LDAX	D
  369/E5FE : BE                         	CMP	M
  370/E5FF : C2 CF E7                   	JNZ	HALT	;jump to halt routine.
  371/E602 : 13                         	INX	D
  372/E603 : 23                         	INX	H
  373/E604 : 05                         	DCR	B
  374/E605 : C2 FD E5                   	JNZ	VERIFY1
  375/E608 : C9                         	RET
  376/E609 :                            ;
  377/E609 :                            ;   Print back file name with a '?' to indicate a syntax error.
  378/E609 :                            ;
  379/E609 : CD 98 E4                   SYNERR	CALL	CRLF	;end current line.
  380/E60C : 2A 8A E4                   	LHLD	NAMEPNT	;this points to name in error.
  381/E60F : 7E                         SYNERR1	MOV	A,M	;print it until a space or null is found.
  382/E610 : FE 20                      	CPI	' '
  383/E612 : CA 22 E6                   	JZ	SYNERR2
  384/E615 : B7                         	ORA	A
  385/E616 : CA 22 E6                   	JZ	SYNERR2
  386/E619 : E5                         	PUSH	H
  387/E61A : CD 8C E4                   	CALL	PRINT
  388/E61D : E1                         	POP	H
  389/E61E : 23                         	INX	H
  390/E61F : C3 0F E6                   	JMP	SYNERR1
  391/E622 : 3E 3F                      SYNERR2	MVI	A,'?'	;add trailing '?'.
  392/E624 : CD 8C E4                   	CALL	PRINT
  393/E627 : CD 98 E4                   	CALL	CRLF
  394/E62A : CD DD E5                   	CALL	DELBATCH;delete any batch file.
  395/E62D : C3 82 E7                   	JMP	CMMND1	;and restart from console input.
  396/E630 :                            ;
  397/E630 :                            ;   Check character at (DE) for legal command input. Note that the
  398/E630 :                            ; zero flag is set if the character is a delimiter.
  399/E630 :                            ;
  400/E630 : 1A                         CHECK	LDAX	D
  401/E631 : B7                         	ORA	A
  402/E632 : C8                         	RZ
  403/E633 : FE 20                      	CPI	' '	;control characters are not legal here.
  404/E635 : DA 09 E6                   	JC	SYNERR
  405/E638 : C8                         	RZ		;check for valid delimiter.
  406/E639 : FE 3D                      	CPI	'='
  407/E63B : C8                         	RZ
  408/E63C : FE 5F                      	CPI	'_'
  409/E63E : C8                         	RZ
  410/E63F : FE 2E                      	CPI	'.'
  411/E641 : C8                         	RZ
  412/E642 : FE 3A                      	CPI	':'
  413/E644 : C8                         	RZ
  414/E645 : FE 3B                      	CPI	';'
  415/E647 : C8                         	RZ
  416/E648 : FE 3C                      	CPI	'<'
  417/E64A : C8                         	RZ
  418/E64B : FE 3E                      	CPI	'>'
  419/E64D : C8                         	RZ
  420/E64E : C9                         	RET
  421/E64F :                            ;
  422/E64F :                            ;   Get the next non-blank character from (DE).
  423/E64F :                            ;
  424/E64F : 1A                         NONBLANK:LDAX	D
  425/E650 : B7                         	ORA	A	;string ends with a null.
  426/E651 : C8                         	RZ
  427/E652 : FE 20                      	CPI	' '
  428/E654 : C0                         	RNZ
  429/E655 : 13                         	INX	D
  430/E656 : C3 4F E6                   	JMP	NONBLANK
  431/E659 :                            ;
  432/E659 :                            ;   Add (HL)=(HL)+(A)
  433/E659 :                            ;
  434/E659 : 85                         ADDHL	ADD	L
  435/E65A : 6F                         	MOV	L,A
  436/E65B : D0                         	RNC	;take care of any carry.
  437/E65C : 24                         	INR	H
  438/E65D : C9                         	RET
  439/E65E :                            ;
  440/E65E :                            ;   Convert the first name in (FCB).
  441/E65E :                            ;
  442/E65E : 3E 00                      CONVFST	MVI	A,0
  443/E660 :                            ;
  444/E660 :                            ;   Format a file name (convert * to '?', etc.). On return,
  445/E660 :                            ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
  446/E660 :                            ; the position within the fcb for the name (either 0 or 16).
  447/E660 :                            ;
  448/E660 : 21 CD EB                   CONVERT	LXI	H,FCB
  449/E663 : CD 59 E6                   	CALL	ADDHL
  450/E666 : E5                         	PUSH	H
  451/E667 : E5                         	PUSH	H
  452/E668 : AF                         	XRA	A
  453/E669 : 32 F0 EB                   	STA	CHGDRV	;initialize drive change flag.
  454/E66C : 2A 88 E4                   	LHLD	INPOINT	;set (HL) as pointer into input line.
  455/E66F : EB                         	XCHG
  456/E670 : CD 4F E6                   	CALL	NONBLANK;get next non-blank character.
  457/E673 : EB                         	XCHG
  458/E674 : 22 8A E4                   	SHLD	NAMEPNT	;save pointer here for any error message.
  459/E677 : EB                         	XCHG
  460/E678 : E1                         	POP	H
  461/E679 : 1A                         	LDAX	D	;get first character.
  462/E67A : B7                         	ORA	A
  463/E67B : CA 89 E6                   	JZ	CONVRT1
  464/E67E : DE 40                      	SBI	'A'-1	;might be a drive name, convert to binary.
  465/E680 : 47                         	MOV	B,A	;and save.
  466/E681 : 13                         	INX	D	;check next character for a ':'.
  467/E682 : 1A                         	LDAX	D
  468/E683 : FE 3A                      	CPI	':'
  469/E685 : CA 90 E6                   	JZ	CONVRT2
  470/E688 : 1B                         	DCX	D	;nope, move pointer back to the start of the line.
  471/E689 : 3A EF EB                   CONVRT1	LDA	CDRIVE
  472/E68C : 77                         	MOV	M,A
  473/E68D : C3 96 E6                   	JMP	CONVRT3
  474/E690 : 78                         CONVRT2	MOV	A,B
  475/E691 : 32 F0 EB                   	STA	CHGDRV	;set change in drives flag.
  476/E694 : 70                         	MOV	M,B
  477/E695 : 13                         	INX	D
  478/E696 :                            ;
  479/E696 :                            ;   Convert the basic file name.
  480/E696 :                            ;
  481/E696 : 06 08                      CONVRT3	MVI	B,08H
  482/E698 : CD 30 E6                   CONVRT4	CALL	CHECK
  483/E69B : CA B9 E6                   	JZ	CONVRT8
  484/E69E : 23                         	INX	H
  485/E69F : FE 2A                      	CPI	'*'	;note that an '*' will fill the remaining
  486/E6A1 : C2 A9 E6                   	JNZ	CONVRT5	;field with '?'.
  487/E6A4 : 36 3F                      	MVI	M,'?'
  488/E6A6 : C3 AB E6                   	JMP	CONVRT6
  489/E6A9 : 77                         CONVRT5	MOV	M,A
  490/E6AA : 13                         	INX	D
  491/E6AB : 05                         CONVRT6	DCR	B
  492/E6AC : C2 98 E6                   	JNZ	CONVRT4
  493/E6AF : CD 30 E6                   CONVRT7	CALL	CHECK	;get next delimiter.
  494/E6B2 : CA C0 E6                   	JZ	GETEXT
  495/E6B5 : 13                         	INX	D
  496/E6B6 : C3 AF E6                   	JMP	CONVRT7
  497/E6B9 : 23                         CONVRT8	INX	H	;blank fill the file name.
  498/E6BA : 36 20                      	MVI	M,' '
  499/E6BC : 05                         	DCR	B
  500/E6BD : C2 B9 E6                   	JNZ	CONVRT8
  501/E6C0 :                            ;
  502/E6C0 :                            ;   Get the extension and convert it.
  503/E6C0 :                            ;
  504/E6C0 : 06 03                      GETEXT	MVI	B,03H
  505/E6C2 : FE 2E                      	CPI	'.'
  506/E6C4 : C2 E9 E6                   	JNZ	GETEXT5
  507/E6C7 : 13                         	INX	D
  508/E6C8 : CD 30 E6                   GETEXT1	CALL	CHECK
  509/E6CB : CA E9 E6                   	JZ	GETEXT5
  510/E6CE : 23                         	INX	H
  511/E6CF : FE 2A                      	CPI	'*'
  512/E6D1 : C2 D9 E6                   	JNZ	GETEXT2
  513/E6D4 : 36 3F                      	MVI	M,'?'
  514/E6D6 : C3 DB E6                   	JMP	GETEXT3
  515/E6D9 : 77                         GETEXT2	MOV	M,A
  516/E6DA : 13                         	INX	D
  517/E6DB : 05                         GETEXT3	DCR	B
  518/E6DC : C2 C8 E6                   	JNZ	GETEXT1
  519/E6DF : CD 30 E6                   GETEXT4	CALL	CHECK
  520/E6E2 : CA F0 E6                   	JZ	GETEXT6
  521/E6E5 : 13                         	INX	D
  522/E6E6 : C3 DF E6                   	JMP	GETEXT4
  523/E6E9 : 23                         GETEXT5	INX	H
  524/E6EA : 36 20                      	MVI	M,' '
  525/E6EC : 05                         	DCR	B
  526/E6ED : C2 E9 E6                   	JNZ	GETEXT5
  527/E6F0 : 06 03                      GETEXT6	MVI	B,3
  528/E6F2 : 23                         GETEXT7	INX	H
  529/E6F3 : 36 00                      	MVI	M,0
  530/E6F5 : 05                         	DCR	B
  531/E6F6 : C2 F2 E6                   	JNZ	GETEXT7
  532/E6F9 : EB                         	XCHG
  533/E6FA : 22 88 E4                   	SHLD	INPOINT	;save input line pointer.
  534/E6FD : E1                         	POP	H
  535/E6FE :                            ;
  536/E6FE :                            ;   Check to see if this is an ambigeous file name specification.
  537/E6FE :                            ; Set the (A) register to non zero if it is.
  538/E6FE :                            ;
  539/E6FE : 01 0B 00                   	LXI	B,11	;set name length.
  540/E701 : 23                         GETEXT8	INX	H
  541/E702 : 7E                         	MOV	A,M
  542/E703 : FE 3F                      	CPI	'?'	;any question marks?
  543/E705 : C2 09 E7                   	JNZ	GETEXT9
  544/E708 : 04                         	INR	B	;count them.
  545/E709 : 0D                         GETEXT9	DCR	C
  546/E70A : C2 01 E7                   	JNZ	GETEXT8
  547/E70D : 78                         	MOV	A,B
  548/E70E : B7                         	ORA	A
  549/E70F : C9                         	RET
  550/E710 :                            ;
  551/E710 :                            ;   CP/M command table. Note commands can be either 3 or 4 characters long.
  552/E710 :                            ;
  553/E710 : =6H                        NUMCMDS	EQU	6	;number of commands
  554/E710 : 44 49 52 20                CMDTBL	DB	'DIR '
  555/E714 : 45 52 41 20                	DB	'ERA '
  556/E718 : 54 59 50 45                	DB	'TYPE'
  557/E71C : 53 41 56 45                	DB	'SAVE'
  558/E720 : 52 45 4E 20                	DB	'REN '
  559/E724 : 55 53 45 52                	DB	'USER'
  560/E728 :                            ;
  561/E728 :                            ;   The following six bytes must agree with those at (PATTRN2)
  562/E728 :                            ; or cp/m will HALT. Why?
  563/E728 :                            ;
  564/E728 : 00 16 00 00 00 00          PATTRN1	DB	0,22,0,0,0,0;(* serial number bytes *).
  565/E72E :                            ;
  566/E72E :                            ;   Search the command table for a match with what has just
  567/E72E :                            ; been entered. If a match is found, then we jump to the
  568/E72E :                            ; proper section. Else jump to (UNKNOWN).
  569/E72E :                            ; On return, the (C) register is set to the command number
  570/E72E :                            ; that matched (or NUMCMDS+1 if no match).
  571/E72E :                            ;
  572/E72E : 21 10 E7                   SEARCH	LXI	H,CMDTBL
  573/E731 : 0E 00                      	MVI	C,0
  574/E733 : 79                         SEARCH1	MOV	A,C
  575/E734 : FE 06                      	CPI	NUMCMDS	;this commands exists.
  576/E736 : D0                         	RNC
  577/E737 : 11 CE EB                   	LXI	D,FCB+1	;check this one.
  578/E73A : 06 04                      	MVI	B,4	;max command length.
  579/E73C : 1A                         SEARCH2	LDAX	D
  580/E73D : BE                         	CMP	M
  581/E73E : C2 4F E7                   	JNZ	SEARCH3	;not a match.
  582/E741 : 13                         	INX	D
  583/E742 : 23                         	INX	H
  584/E743 : 05                         	DCR	B
  585/E744 : C2 3C E7                   	JNZ	SEARCH2
  586/E747 : 1A                         	LDAX	D	;allow a 3 character command to match.
  587/E748 : FE 20                      	CPI	' '
  588/E74A : C2 54 E7                   	JNZ	SEARCH4
  589/E74D : 79                         	MOV	A,C	;set return register for this command.
  590/E74E : C9                         	RET
  591/E74F : 23                         SEARCH3	INX	H
  592/E750 : 05                         	DCR	B
  593/E751 : C2 4F E7                   	JNZ	SEARCH3
  594/E754 : 0C                         SEARCH4	INR	C
  595/E755 : C3 33 E7                   	JMP	SEARCH1
  596/E758 :                            ;
  597/E758 :                            ;   Set the input buffer to empty and then start the command
  598/E758 :                            ; processor (ccp).
  599/E758 :                            ;
  600/E758 : AF                         CLEARBUF:XRA	A
  601/E759 : 32 07 E4                   	STA	INBUFF+1;second byte is actual length.
  602/E75C :                            ;
  603/E75C :                            ;**************************************************************
  604/E75C :                            ;*
  605/E75C :                            ;*
  606/E75C :                            ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
  607/E75C :                            ;*
  608/E75C :                            ;**************************************************************
  609/E75C :                            ;*
  610/E75C : 31 AB EB                   COMMAND	LXI	SP,CCPSTACK;setup stack area.
  611/E75F : C5                         	PUSH	B	;note that (C) should be equal to:
  612/E760 : 79                         	MOV	A,C	;(uuuudddd) where 'uuuu' is the user number
  613/E761 : 1F                         	RAR		;and 'dddd' is the drive number.
  614/E762 : 1F                         	RAR
  615/E763 : 1F                         	RAR
  616/E764 : 1F                         	RAR
  617/E765 : E6 0F                      	ANI	0FH	;isolate the user number.
  618/E767 : 5F                         	MOV	E,A
  619/E768 : CD 15 E5                   	CALL	GETSETUC;and set it.
  620/E76B : CD B8 E4                   	CALL	RESDSK	;reset the disk system.
  621/E76E : 32 AB EB                   	STA	BATCH	;clear batch mode flag.
  622/E771 : C1                         	POP	B
  623/E772 : 79                         	MOV	A,C
  624/E773 : E6 0F                      	ANI	0FH	;isolate the drive number.
  625/E775 : 32 EF EB                   	STA	CDRIVE	;and save.
  626/E778 : CD BD E4                   	CALL	DSKSEL	;...and select.
  627/E77B : 3A 07 E4                   	LDA	INBUFF+1
  628/E77E : B7                         	ORA	A	;anything in input buffer already?
  629/E77F : C2 98 E7                   	JNZ	CMMND2	;yes, we just process it.
  630/E782 :                            ;
  631/E782 :                            ;   Entry point to get a command line from the console.
  632/E782 :                            ;
  633/E782 : 31 AB EB                   CMMND1	LXI	SP,CCPSTACK;set stack straight.
  634/E785 : CD 98 E4                   	CALL	CRLF	;start a new line on the screen.
  635/E788 : CD D0 E5                   	CALL	GETDSK	;get current drive.
  636/E78B : C6 41                      	ADI	'A'
  637/E78D : CD 8C E4                   	CALL	PRINT	;print current drive.
  638/E790 : 3E 3E                      	MVI	A,'>'
  639/E792 : CD 8C E4                   	CALL	PRINT	;and add prompt.
  640/E795 : CD 39 E5                   	CALL	GETINP	;get line from user.
  641/E798 :                            ;
  642/E798 :                            ;   Process command line here.
  643/E798 :                            ;
  644/E798 : 11 80 00                   CMMND2	LXI	D,TBUFF
  645/E79B : CD D8 E5                   	CALL	DMASET	;set standard dma address.
  646/E79E : CD D0 E5                   	CALL	GETDSK
  647/E7A1 : 32 EF EB                   	STA	CDRIVE	;set current drive.
  648/E7A4 : CD 5E E6                   	CALL	CONVFST	;convert name typed in.
  649/E7A7 : C4 09 E6                   	CNZ	SYNERR	;wild cards are not allowed.
  650/E7AA : 3A F0 EB                   	LDA	CHGDRV	;if a change in drives was indicated,
  651/E7AD : B7                         	ORA	A	;then treat this as an unknown command
  652/E7AE : C2 A5 EA                   	JNZ	UNKNOWN	;which gets executed.
  653/E7B1 : CD 2E E7                   	CALL	SEARCH	;else search command table for a match.
  654/E7B4 :                            ;
  655/E7B4 :                            ;   Note that an unknown command returns
  656/E7B4 :                            ; with (A) pointing to the last address
  657/E7B4 :                            ; in our table which is (UNKNOWN).
  658/E7B4 :                            ;
  659/E7B4 : 21 C1 E7                   	LXI	H,CMDADR;now, look thru our address table for command (A).
  660/E7B7 : 5F                         	MOV	E,A	;set (DE) to command number.
  661/E7B8 : 16 00                      	MVI	D,0
  662/E7BA : 19                         	DAD	D
  663/E7BB : 19                         	DAD	D	;(HL)=(CMDADR)+2*(command number).
  664/E7BC : 7E                         	MOV	A,M	;now pick out this address.
  665/E7BD : 23                         	INX	H
  666/E7BE : 66                         	MOV	H,M
  667/E7BF : 6F                         	MOV	L,A
  668/E7C0 : E9                         	PCHL		;now execute it.
  669/E7C1 :                            ;
  670/E7C1 :                            ;   CP/M command address table.
  671/E7C1 :                            ;
  672/E7C1 : 77 E8 1F E9 5D E9 AD E9    CMDADR	DW	DIRECT,ERASE,TYPE,SAVE
  673/E7C9 : 10 EA 8E EA A5 EA          	DW	RENAME,USER,UNKNOWN
  674/E7CF :                            ;
  675/E7CF :                            ;   Halt the system. Reason for this is unknown at present.
  676/E7CF :                            ;
  677/E7CF : 21 F3 76                   HALT	LXI	H,76F3H	;'DI HLT' instructions.
  678/E7D2 : 22 00 E4                   	SHLD	CBASE
  679/E7D5 : 21 00 E4                   	LXI	H,CBASE
  680/E7D8 : E9                         	PCHL
  681/E7D9 :                            ;
  682/E7D9 :                            ;   Read error while TYPEing a file.
  683/E7D9 :                            ;
  684/E7D9 : 01 DF E7                   RDERROR	LXI	B,RDERR
  685/E7DC : C3 A7 E4                   	JMP	PLINE
  686/E7DF : 52 65 61 64 20 65 72 72 6F RDERR	DB	'Read error',0
      E7E8 : 72 00                     
  687/E7EA :                            ;
  688/E7EA :                            ;   Required file was not located.
  689/E7EA :                            ;
  690/E7EA : 01 F0 E7                   NONE	LXI	B,NOFILE
  691/E7ED : C3 A7 E4                   	JMP	PLINE
  692/E7F0 : 4E 6F 20 66 69 6C 65 00    NOFILE	DB	'No file',0
  693/E7F8 :                            ;
  694/E7F8 :                            ;   Decode a command of the form 'A>filename number{ filename}.
  695/E7F8 :                            ; Note that a drive specifier is not allowed on the first file
  696/E7F8 :                            ; name. On return, the number is in register (A). Any error
  697/E7F8 :                            ; causes 'filename?' to be printed and the command is aborted.
  698/E7F8 :                            ;
  699/E7F8 : CD 5E E6                   DECODE	CALL	CONVFST	;convert filename.
  700/E7FB : 3A F0 EB                   	LDA	CHGDRV	;do not allow a drive to be specified.
  701/E7FE : B7                         	ORA	A
  702/E7FF : C2 09 E6                   	JNZ	SYNERR
  703/E802 : 21 CE EB                   	LXI	H,FCB+1	;convert number now.
  704/E805 : 01 0B 00                   	LXI	B,11	;(B)=sum register, (C)=max digit count.
  705/E808 : 7E                         DECODE1	MOV	A,M
  706/E809 : FE 20                      	CPI	' '	;a space terminates the numeral.
  707/E80B : CA 33 E8                   	JZ	DECODE3
  708/E80E : 23                         	INX	H
  709/E80F : D6 30                      	SUI	'0'	;make binary from ascii.
  710/E811 : FE 0A                      	CPI	10	;legal digit?
  711/E813 : D2 09 E6                   	JNC	SYNERR
  712/E816 : 57                         	MOV	D,A	;yes, save it in (D).
  713/E817 : 78                         	MOV	A,B	;compute (B)=(B)*10 and check for overflow.
  714/E818 : E6 E0                      	ANI	0E0H
  715/E81A : C2 09 E6                   	JNZ	SYNERR
  716/E81D : 78                         	MOV	A,B
  717/E81E : 07                         	RLC
  718/E81F : 07                         	RLC
  719/E820 : 07                         	RLC	;(A)=(B)*8
  720/E821 : 80                         	ADD	B	;.......*9
  721/E822 : DA 09 E6                   	JC	SYNERR
  722/E825 : 80                         	ADD	B	;.......*10
  723/E826 : DA 09 E6                   	JC	SYNERR
  724/E829 : 82                         	ADD	D	;add in new digit now.
  725/E82A : DA 09 E6                   DECODE2	JC	SYNERR
  726/E82D : 47                         	MOV	B,A	;and save result.
  727/E82E : 0D                         	DCR	C	;only look at 11 digits.
  728/E82F : C2 08 E8                   	JNZ	DECODE1
  729/E832 : C9                         	RET
  730/E833 : 7E                         DECODE3	MOV	A,M	;spaces must follow (why?).
  731/E834 : FE 20                      	CPI	' '
  732/E836 : C2 09 E6                   	JNZ	SYNERR
  733/E839 : 23                         	INX	H
  734/E83A : 0D                         DECODE4	DCR	C
  735/E83B : C2 33 E8                   	JNZ	DECODE3
  736/E83E : 78                         	MOV	A,B	;set (A)=the numeric value entered.
  737/E83F : C9                         	RET
  738/E840 :                            ;
  739/E840 :                            ;   Move 3 bytes from (HL) to (DE). Note that there is only
  740/E840 :                            ; one reference to this at (A2D5h).
  741/E840 :                            ;
  742/E840 : 06 03                      MOVE3	MVI	B,3
  743/E842 :                            ;
  744/E842 :                            ;   Move (B) bytes from (HL) to (DE).
  745/E842 :                            ;
  746/E842 : 7E                         HL2DE	MOV	A,M
  747/E843 : 12                         	STAX	D
  748/E844 : 23                         	INX	H
  749/E845 : 13                         	INX	D
  750/E846 : 05                         	DCR	B
  751/E847 : C2 42 E8                   	JNZ	HL2DE
  752/E84A : C9                         	RET
  753/E84B :                            ;
  754/E84B :                            ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
  755/E84B :                            ;
  756/E84B : 21 80 00                   EXTRACT	LXI	H,TBUFF
  757/E84E : 81                         	ADD	C
  758/E84F : CD 59 E6                   	CALL	ADDHL
  759/E852 : 7E                         	MOV	A,M
  760/E853 : C9                         	RET
  761/E854 :                            ;
  762/E854 :                            ;  Check drive specified. If it means a change, then the new
  763/E854 :                            ; drive will be selected. In any case, the drive byte of the
  764/E854 :                            ; fcb will be set to null (means use current drive).
  765/E854 :                            ;
  766/E854 : AF                         DSELECT	XRA	A	;null out first byte of fcb.
  767/E855 : 32 CD EB                   	STA	FCB
  768/E858 : 3A F0 EB                   	LDA	CHGDRV	;a drive change indicated?
  769/E85B : B7                         	ORA	A
  770/E85C : C8                         	RZ
  771/E85D : 3D                         	DCR	A	;yes, is it the same as the current drive?
  772/E85E : 21 EF EB                   	LXI	H,CDRIVE
  773/E861 : BE                         	CMP	M
  774/E862 : C8                         	RZ
  775/E863 : C3 BD E4                   	JMP	DSKSEL	;no. Select it then.
  776/E866 :                            ;
  777/E866 :                            ;   Check the drive selection and reset it to the previous
  778/E866 :                            ; drive if it was changed for the preceeding command.
  779/E866 :                            ;
  780/E866 : 3A F0 EB                   RESETDR	LDA	CHGDRV	;drive change indicated?
  781/E869 : B7                         	ORA	A
  782/E86A : C8                         	RZ
  783/E86B : 3D                         	DCR	A	;yes, was it a different drive?
  784/E86C : 21 EF EB                   	LXI	H,CDRIVE
  785/E86F : BE                         	CMP	M
  786/E870 : C8                         	RZ
  787/E871 : 3A EF EB                   	LDA	CDRIVE	;yes, re-select our old drive.
  788/E874 : C3 BD E4                   	JMP	DSKSEL
  789/E877 :                            ;
  790/E877 :                            ;**************************************************************
  791/E877 :                            ;*
  792/E877 :                            ;*           D I R E C T O R Y   C O M M A N D
  793/E877 :                            ;*
  794/E877 :                            ;**************************************************************
  795/E877 :                            ;
  796/E877 : CD 5E E6                   DIRECT	CALL	CONVFST	;convert file name.
  797/E87A : CD 54 E8                   	CALL	DSELECT	;select indicated drive.
  798/E87D : 21 CE EB                   	LXI	H,FCB+1	;was any file indicated?
  799/E880 : 7E                         	MOV	A,M
  800/E881 : FE 20                      	CPI	' '
  801/E883 : C2 8F E8                   	JNZ	DIRECT2
  802/E886 : 06 0B                      	MVI	B,11	;no. Fill field with '?' - same as *.*.
  803/E888 : 36 3F                      DIRECT1	MVI	M,'?'
  804/E88A : 23                         	INX	H
  805/E88B : 05                         	DCR	B
  806/E88C : C2 88 E8                   	JNZ	DIRECT1
  807/E88F : 1E 00                      DIRECT2	MVI	E,0	;set initial cursor position.
  808/E891 : D5                         	PUSH	D
  809/E892 : CD E9 E4                   	CALL	SRCHFCB	;get first file name.
  810/E895 : CC EA E7                   	CZ	NONE	;none found at all?
  811/E898 : CA 1B E9                   DIRECT3	JZ	DIRECT9	;terminate if no more names.
  812/E89B : 3A EE EB                   	LDA	RTNCODE	;get file's position in segment (0-3).
  813/E89E : 0F                         	RRC
  814/E89F : 0F                         	RRC
  815/E8A0 : 0F                         	RRC
  816/E8A1 : E6 60                      	ANI	60H	;(A)=position*32
  817/E8A3 : 4F                         	MOV	C,A
  818/E8A4 : 3E 0A                      	MVI	A,10
  819/E8A6 : CD 4B E8                   	CALL	EXTRACT	;extract the tenth entry in fcb.
  820/E8A9 : 17                         	RAL		;check system file status bit.
  821/E8AA : DA 0F E9                   	JC	DIRECT8	;we don't list them.
  822/E8AD : D1                         	POP	D
  823/E8AE : 7B                         	MOV	A,E	;bump name count.
  824/E8AF : 1C                         	INR	E
  825/E8B0 : D5                         	PUSH	D
  826/E8B1 : E6 03                      	ANI	03H	;at end of line?
  827/E8B3 : F5                         	PUSH	PSW
  828/E8B4 : C2 CC E8                   	JNZ	DIRECT4
  829/E8B7 : CD 98 E4                   	CALL	CRLF	;yes, end this line and start another.
  830/E8BA : C5                         	PUSH	B
  831/E8BB : CD D0 E5                   	CALL	GETDSK	;start line with ('A:').
  832/E8BE : C1                         	POP	B
  833/E8BF : C6 41                      	ADI	'A'
  834/E8C1 : CD 92 E4                   	CALL	PRINTB
  835/E8C4 : 3E 3A                      	MVI	A,':'
  836/E8C6 : CD 92 E4                   	CALL	PRINTB
  837/E8C9 : C3 D4 E8                   	JMP	DIRECT5
  838/E8CC : CD A2 E4                   DIRECT4	CALL	SPACE	;add seperator between file names.
  839/E8CF : 3E 3A                      	MVI	A,':'
  840/E8D1 : CD 92 E4                   	CALL	PRINTB
  841/E8D4 : CD A2 E4                   DIRECT5	CALL	SPACE
  842/E8D7 : 06 01                      	MVI	B,1	;'extract' each file name character at a time.
  843/E8D9 : 78                         DIRECT6	MOV	A,B
  844/E8DA : CD 4B E8                   	CALL	EXTRACT
  845/E8DD : E6 7F                      	ANI	7FH	;strip bit 7 (status bit).
  846/E8DF : FE 20                      	CPI	' '	;are we at the end of the name?
  847/E8E1 : C2 F9 E8                   	JNZ	DRECT65
  848/E8E4 : F1                         	POP	PSW	;yes, don't print spaces at the end of a line.
  849/E8E5 : F5                         	PUSH	PSW
  850/E8E6 : FE 03                      	CPI	3
  851/E8E8 : C2 F7 E8                   	JNZ	DRECT63
  852/E8EB : 3E 09                      	MVI	A,9	;first check for no extension.
  853/E8ED : CD 4B E8                   	CALL	EXTRACT
  854/E8F0 : E6 7F                      	ANI	7FH
  855/E8F2 : FE 20                      	CPI	' '
  856/E8F4 : CA 0E E9                   	JZ	DIRECT7	;don't print spaces.
  857/E8F7 : 3E 20                      DRECT63	MVI	A,' '	;else print them.
  858/E8F9 : CD 92 E4                   DRECT65	CALL	PRINTB
  859/E8FC : 04                         	INR	B	;bump to next character psoition.
  860/E8FD : 78                         	MOV	A,B
  861/E8FE : FE 0C                      	CPI	12	;end of the name?
  862/E900 : D2 0E E9                   	JNC	DIRECT7
  863/E903 : FE 09                      	CPI	9	;nope, starting extension?
  864/E905 : C2 D9 E8                   	JNZ	DIRECT6
  865/E908 : CD A2 E4                   	CALL	SPACE	;yes, add seperating space.
  866/E90B : C3 D9 E8                   	JMP	DIRECT6
  867/E90E : F1                         DIRECT7	POP	PSW	;get the next file name.
  868/E90F : CD C2 E5                   DIRECT8	CALL	CHKCON	;first check console, quit on anything.
  869/E912 : C2 1B E9                   	JNZ	DIRECT9
  870/E915 : CD E4 E4                   	CALL	SRCHNXT	;get next name.
  871/E918 : C3 98 E8                   	JMP	DIRECT3	;and continue with our list.
  872/E91B : D1                         DIRECT9	POP	D	;restore the stack and return to command level.
  873/E91C : C3 86 EB                   	JMP	GETBACK
  874/E91F :                            ;
  875/E91F :                            ;**************************************************************
  876/E91F :                            ;*
  877/E91F :                            ;*                E R A S E   C O M M A N D
  878/E91F :                            ;*
  879/E91F :                            ;**************************************************************
  880/E91F :                            ;
  881/E91F : CD 5E E6                   ERASE	CALL	CONVFST	;convert file name.
  882/E922 : FE 0B                      	CPI	11	;was '*.*' entered?
  883/E924 : C2 42 E9                   	JNZ	ERASE1
  884/E927 : 01 52 E9                   	LXI	B,YESNO	;yes, ask for confirmation.
  885/E92A : CD A7 E4                   	CALL	PLINE
  886/E92D : CD 39 E5                   	CALL	GETINP
  887/E930 : 21 07 E4                   	LXI	H,INBUFF+1
  888/E933 : 35                         	DCR	M	;must be exactly 'y'.
  889/E934 : C2 82 E7                   	JNZ	CMMND1
  890/E937 : 23                         	INX	H
  891/E938 : 7E                         	MOV	A,M
  892/E939 : FE 59                      	CPI	'Y'
  893/E93B : C2 82 E7                   	JNZ	CMMND1
  894/E93E : 23                         	INX	H
  895/E93F : 22 88 E4                   	SHLD	INPOINT	;save input line pointer.
  896/E942 : CD 54 E8                   ERASE1	CALL	DSELECT	;select desired disk.
  897/E945 : 11 CD EB                   	LXI	D,FCB
  898/E948 : CD EF E4                   	CALL	DELETE	;delete the file.
  899/E94B : 3C                         	INR	A
  900/E94C : CC EA E7                   	CZ	NONE	;not there?
  901/E94F : C3 86 EB                   	JMP	GETBACK	;return to command level now.
  902/E952 : 41 6C 6C 20 28 79 2F 6E 29 YESNO	DB	'All (y/n)?',0
      E95B : 3F 00                     
  903/E95D :                            ;
  904/E95D :                            ;**************************************************************
  905/E95D :                            ;*
  906/E95D :                            ;*            T Y P E   C O M M A N D
  907/E95D :                            ;*
  908/E95D :                            ;**************************************************************
  909/E95D :                            ;
  910/E95D : CD 5E E6                   TYPE	CALL	CONVFST	;convert file name.
  911/E960 : C2 09 E6                   	JNZ	SYNERR	;wild cards not allowed.
  912/E963 : CD 54 E8                   	CALL	DSELECT	;select indicated drive.
  913/E966 : CD D0 E4                   	CALL	OPENFCB	;open the file.
  914/E969 : CA A7 E9                   	JZ	TYPE5	;not there?
  915/E96C : CD 98 E4                   	CALL	CRLF	;ok, start a new line on the screen.
  916/E96F : 21 F1 EB                   	LXI	H,NBYTES;initialize byte counter.
  917/E972 : 36 FF                      	MVI	M,0FFH	;set to read first sector.
  918/E974 : 21 F1 EB                   TYPE1	LXI	H,NBYTES
  919/E977 : 7E                         TYPE2	MOV	A,M	;have we written the entire sector?
  920/E978 : FE 80                      	CPI	128
  921/E97A : DA 87 E9                   	JC	TYPE3
  922/E97D : E5                         	PUSH	H	;yes, read in the next one.
  923/E97E : CD FE E4                   	CALL	READFCB
  924/E981 : E1                         	POP	H
  925/E982 : C2 A0 E9                   	JNZ	TYPE4	;end or error?
  926/E985 : AF                         	XRA	A	;ok, clear byte counter.
  927/E986 : 77                         	MOV	M,A
  928/E987 : 34                         TYPE3	INR	M	;count this byte.
  929/E988 : 21 80 00                   	LXI	H,TBUFF	;and get the (A)th one from the buffer (TBUFF).
  930/E98B : CD 59 E6                   	CALL	ADDHL
  931/E98E : 7E                         	MOV	A,M
  932/E98F : FE 1A                      	CPI	CNTRLZ	;end of file mark?
  933/E991 : CA 86 EB                   	JZ	GETBACK
  934/E994 : CD 8C E4                   	CALL	PRINT	;no, print it.
  935/E997 : CD C2 E5                   	CALL	CHKCON	;check console, quit if anything ready.
  936/E99A : C2 86 EB                   	JNZ	GETBACK
  937/E99D : C3 74 E9                   	JMP	TYPE1
  938/E9A0 :                            ;
  939/E9A0 :                            ;   Get here on an end of file or read error.
  940/E9A0 :                            ;
  941/E9A0 : 3D                         TYPE4	DCR	A	;read error?
  942/E9A1 : CA 86 EB                   	JZ	GETBACK
  943/E9A4 : CD D9 E7                   	CALL	RDERROR	;yes, print message.
  944/E9A7 : CD 66 E8                   TYPE5	CALL	RESETDR	;and reset proper drive
  945/E9AA : C3 09 E6                   	JMP	SYNERR	;now print file name with problem.
  946/E9AD :                            ;
  947/E9AD :                            ;**************************************************************
  948/E9AD :                            ;*
  949/E9AD :                            ;*            S A V E   C O M M A N D
  950/E9AD :                            ;*
  951/E9AD :                            ;**************************************************************
  952/E9AD :                            ;
  953/E9AD : CD F8 E7                   SAVE	CALL	DECODE	;get numeric number that follows SAVE.
  954/E9B0 : F5                         	PUSH	PSW	;save number of pages to write.
  955/E9B1 : CD 5E E6                   	CALL	CONVFST	;convert file name.
  956/E9B4 : C2 09 E6                   	JNZ	SYNERR	;wild cards not allowed.
  957/E9B7 : CD 54 E8                   	CALL	DSELECT	;select specified drive.
  958/E9BA : 11 CD EB                   	LXI	D,FCB	;now delete this file.
  959/E9BD : D5                         	PUSH	D
  960/E9BE : CD EF E4                   	CALL	DELETE
  961/E9C1 : D1                         	POP	D
  962/E9C2 : CD 09 E5                   	CALL	CREATE	;and create it again.
  963/E9C5 : CA FB E9                   	JZ	SAVE3	;can't create?
  964/E9C8 : AF                         	XRA	A	;clear record number byte.
  965/E9C9 : 32 ED EB                   	STA	FCB+32
  966/E9CC : F1                         	POP	PSW	;convert pages to sectors.
  967/E9CD : 6F                         	MOV	L,A
  968/E9CE : 26 00                      	MVI	H,0
  969/E9D0 : 29                         	DAD	H	;(HL)=number of sectors to write.
  970/E9D1 : 11 00 01                   	LXI	D,TBASE	;and we start from here.
  971/E9D4 : 7C                         SAVE1	MOV	A,H	;done yet?
  972/E9D5 : B5                         	ORA	L
  973/E9D6 : CA F1 E9                   	JZ	SAVE2
  974/E9D9 : 2B                         	DCX	H	;nope, count this and compute the start
  975/E9DA : E5                         	PUSH	H	;of the next 128 byte sector.
  976/E9DB : 21 80 00                   	LXI	H,128
  977/E9DE : 19                         	DAD	D
  978/E9DF : E5                         	PUSH	H	;save it and set the transfer address.
  979/E9E0 : CD D8 E5                   	CALL	DMASET
  980/E9E3 : 11 CD EB                   	LXI	D,FCB	;write out this sector now.
  981/E9E6 : CD 04 E5                   	CALL	WRTREC
  982/E9E9 : D1                         	POP	D	;reset (DE) to the start of the last sector.
  983/E9EA : E1                         	POP	H	;restore sector count.
  984/E9EB : C2 FB E9                   	JNZ	SAVE3	;write error?
  985/E9EE : C3 D4 E9                   	JMP	SAVE1
  986/E9F1 :                            ;
  987/E9F1 :                            ;   Get here after writing all of the file.
  988/E9F1 :                            ;
  989/E9F1 : 11 CD EB                   SAVE2	LXI	D,FCB	;now close the file.
  990/E9F4 : CD DA E4                   	CALL	CLOSE
  991/E9F7 : 3C                         	INR	A	;did it close ok?
  992/E9F8 : C2 01 EA                   	JNZ	SAVE4
  993/E9FB :                            ;
  994/E9FB :                            ;   Print out error message (no space).
  995/E9FB :                            ;
  996/E9FB : 01 07 EA                   SAVE3	LXI	B,NOSPACE
  997/E9FE : CD A7 E4                   	CALL	PLINE
  998/EA01 : CD D5 E5                   SAVE4	CALL	STDDMA	;reset the standard dma address.
  999/EA04 : C3 86 EB                   	JMP	GETBACK
 1000/EA07 : 4E 6F 20 73 70 61 63 65 00 NOSPACE	DB	'No space',0
 1001/EA10 :                            ;
 1002/EA10 :                            ;**************************************************************
 1003/EA10 :                            ;*
 1004/EA10 :                            ;*           R E N A M E   C O M M A N D
 1005/EA10 :                            ;*
 1006/EA10 :                            ;**************************************************************
 1007/EA10 :                            ;
 1008/EA10 : CD 5E E6                   RENAME	CALL	CONVFST	;convert first file name.
 1009/EA13 : C2 09 E6                   	JNZ	SYNERR	;wild cards not allowed.
 1010/EA16 : 3A F0 EB                   	LDA	CHGDRV	;remember any change in drives specified.
 1011/EA19 : F5                         	PUSH	PSW
 1012/EA1A : CD 54 E8                   	CALL	DSELECT	;and select this drive.
 1013/EA1D : CD E9 E4                   	CALL	SRCHFCB	;is this file present?
 1014/EA20 : C2 79 EA                   	JNZ	RENAME6	;yes, print error message.
 1015/EA23 : 21 CD EB                   	LXI	H,FCB	;yes, move this name into second slot.
 1016/EA26 : 11 DD EB                   	LXI	D,FCB+16
 1017/EA29 : 06 10                      	MVI	B,16
 1018/EA2B : CD 42 E8                   	CALL	HL2DE
 1019/EA2E : 2A 88 E4                   	LHLD	INPOINT	;get input pointer.
 1020/EA31 : EB                         	XCHG
 1021/EA32 : CD 4F E6                   	CALL	NONBLANK;get next non blank character.
 1022/EA35 : FE 3D                      	CPI	'='	;only allow an '=' or '_' seperator.
 1023/EA37 : CA 3F EA                   	JZ	RENAME1
 1024/EA3A : FE 5F                      	CPI	'_'
 1025/EA3C : C2 73 EA                   	JNZ	RENAME5
 1026/EA3F : EB                         RENAME1	XCHG
 1027/EA40 : 23                         	INX	H	;ok, skip seperator.
 1028/EA41 : 22 88 E4                   	SHLD	INPOINT	;save input line pointer.
 1029/EA44 : CD 5E E6                   	CALL	CONVFST	;convert this second file name now.
 1030/EA47 : C2 73 EA                   	JNZ	RENAME5	;again, no wild cards.
 1031/EA4A : F1                         	POP	PSW	;if a drive was specified, then it
 1032/EA4B : 47                         	MOV	B,A	;must be the same as before.
 1033/EA4C : 21 F0 EB                   	LXI	H,CHGDRV
 1034/EA4F : 7E                         	MOV	A,M
 1035/EA50 : B7                         	ORA	A
 1036/EA51 : CA 59 EA                   	JZ	RENAME2
 1037/EA54 : B8                         	CMP	B
 1038/EA55 : 70                         	MOV	M,B
 1039/EA56 : C2 73 EA                   	JNZ	RENAME5	;they were different, error.
 1040/EA59 : 70                         RENAME2	MOV	M,B;	reset as per the first file specification.
 1041/EA5A : AF                         	XRA	A
 1042/EA5B : 32 CD EB                   	STA	FCB	;clear the drive byte of the fcb.
 1043/EA5E : CD E9 E4                   RENAME3	CALL	SRCHFCB	;and go look for second file.
 1044/EA61 : CA 6D EA                   	JZ	RENAME4	;doesn't exist?
 1045/EA64 : 11 CD EB                   	LXI	D,FCB
 1046/EA67 : CD 0E E5                   	CALL	RENAM	;ok, rename the file.
 1047/EA6A : C3 86 EB                   	JMP	GETBACK
 1048/EA6D :                            ;
 1049/EA6D :                            ;   Process rename errors here.
 1050/EA6D :                            ;
 1051/EA6D : CD EA E7                   RENAME4	CALL	NONE	;file not there.
 1052/EA70 : C3 86 EB                   	JMP	GETBACK
 1053/EA73 : CD 66 E8                   RENAME5	CALL	RESETDR	;bad command format.
 1054/EA76 : C3 09 E6                   	JMP	SYNERR
 1055/EA79 : 01 82 EA                   RENAME6	LXI	B,EXISTS;destination file already exists.
 1056/EA7C : CD A7 E4                   	CALL	PLINE
 1057/EA7F : C3 86 EB                   	JMP	GETBACK
 1058/EA82 : 46 69 6C 65 20 65 78 69 73 EXISTS	DB	'File exists',0
      EA8B : 74 73 00                  
 1059/EA8E :                            ;
 1060/EA8E :                            ;**************************************************************
 1061/EA8E :                            ;*
 1062/EA8E :                            ;*             U S E R   C O M M A N D
 1063/EA8E :                            ;*
 1064/EA8E :                            ;**************************************************************
 1065/EA8E :                            ;
 1066/EA8E : CD F8 E7                   USER	CALL	DECODE	;get numeric value following command.
 1067/EA91 : FE 10                      	CPI	16	;legal user number?
 1068/EA93 : D2 09 E6                   	JNC	SYNERR
 1069/EA96 : 5F                         	MOV	E,A	;yes but is there anything else?
 1070/EA97 : 3A CE EB                   	LDA	FCB+1
 1071/EA9A : FE 20                      	CPI	' '
 1072/EA9C : CA 09 E6                   	JZ	SYNERR	;yes, that is not allowed.
 1073/EA9F : CD 15 E5                   	CALL	GETSETUC;ok, set user code.
 1074/EAA2 : C3 89 EB                   	JMP	GETBACK1
 1075/EAA5 :                            ;
 1076/EAA5 :                            ;**************************************************************
 1077/EAA5 :                            ;*
 1078/EAA5 :                            ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
 1079/EAA5 :                            ;*
 1080/EAA5 :                            ;**************************************************************
 1081/EAA5 :                            ;
 1082/EAA5 : CD F5 E5                   UNKNOWN	CALL	VERIFY	;check for valid system (why?).
 1083/EAA8 : 3A CE EB                   	LDA	FCB+1	;anything to execute?
 1084/EAAB : FE 20                      	CPI	' '
 1085/EAAD : C2 C4 EA                   	JNZ	UNKWN1
 1086/EAB0 : 3A F0 EB                   	LDA	CHGDRV	;nope, only a drive change?
 1087/EAB3 : B7                         	ORA	A
 1088/EAB4 : CA 89 EB                   	JZ	GETBACK1;neither???
 1089/EAB7 : 3D                         	DCR	A
 1090/EAB8 : 32 EF EB                   	STA	CDRIVE	;ok, store new drive.
 1091/EABB : CD 29 E5                   	CALL	MOVECD	;set (TDRIVE) also.
 1092/EABE : CD BD E4                   	CALL	DSKSEL	;and select this drive.
 1093/EAC1 : C3 89 EB                   	JMP	GETBACK1;then return.
 1094/EAC4 :                            ;
 1095/EAC4 :                            ;   Here a file name was typed. Prepare to execute it.
 1096/EAC4 :                            ;
 1097/EAC4 : 11 D6 EB                   UNKWN1	LXI	D,FCB+9	;an extension specified?
 1098/EAC7 : 1A                         	LDAX	D
 1099/EAC8 : FE 20                      	CPI	' '
 1100/EACA : C2 09 E6                   	JNZ	SYNERR	;yes, not allowed.
 1101/EACD : D5                         UNKWN2	PUSH	D
 1102/EACE : CD 54 E8                   	CALL	DSELECT	;select specified drive.
 1103/EAD1 : D1                         	POP	D
 1104/EAD2 : 21 83 EB                   	LXI	H,COMFILE	;set the extension to 'COM'.
 1105/EAD5 : CD 40 E8                   	CALL	MOVE3
 1106/EAD8 : CD D0 E4                   	CALL	OPENFCB	;and open this file.
 1107/EADB : CA 6B EB                   	JZ	UNKWN9	;not present?
 1108/EADE :                            ;
 1109/EADE :                            ;   Load in the program.
 1110/EADE :                            ;
 1111/EADE : 21 00 01                   	LXI	H,TBASE	;store the program starting here.
 1112/EAE1 : E5                         UNKWN3	PUSH	H
 1113/EAE2 : EB                         	XCHG
 1114/EAE3 : CD D8 E5                   	CALL	DMASET	;set transfer address.
 1115/EAE6 : 11 CD EB                   	LXI	D,FCB	;and read the next record.
 1116/EAE9 : CD F9 E4                   	CALL	RDREC
 1117/EAEC : C2 01 EB                   	JNZ	UNKWN4	;end of file or read error?
 1118/EAEF : E1                         	POP	H	;nope, bump pointer for next sector.
 1119/EAF0 : 11 80 00                   	LXI	D,128
 1120/EAF3 : 19                         	DAD	D
 1121/EAF4 : 11 00 E4                   	LXI	D,CBASE	;enough room for the whole file?
 1122/EAF7 : 7D                         	MOV	A,L
 1123/EAF8 : 93                         	SUB	E
 1124/EAF9 : 7C                         	MOV	A,H
 1125/EAFA : 9A                         	SBB	D
 1126/EAFB : D2 71 EB                   	JNC	UNKWN0	;no, it can't fit.
 1127/EAFE : C3 E1 EA                   	JMP	UNKWN3
 1128/EB01 :                            ;
 1129/EB01 :                            ;   Get here after finished reading.
 1130/EB01 :                            ;
 1131/EB01 : E1                         UNKWN4	POP	H
 1132/EB02 : 3D                         	DCR	A	;normal end of file?
 1133/EB03 : C2 71 EB                   	JNZ	UNKWN0
 1134/EB06 : CD 66 E8                   	CALL	RESETDR	;yes, reset previous drive.
 1135/EB09 : CD 5E E6                   	CALL	CONVFST	;convert the first file name that follows
 1136/EB0C : 21 F0 EB                   	LXI	H,CHGDRV;command name.
 1137/EB0F : E5                         	PUSH	H
 1138/EB10 : 7E                         	MOV	A,M	;set drive code in default fcb.
 1139/EB11 : 32 CD EB                   	STA	FCB
 1140/EB14 : 3E 10                      	MVI	A,16	;put second name 16 bytes later.
 1141/EB16 : CD 60 E6                   	CALL	CONVERT	;convert second file name.
 1142/EB19 : E1                         	POP	H
 1143/EB1A : 7E                         	MOV	A,M	;and set the drive for this second file.
 1144/EB1B : 32 DD EB                   	STA	FCB+16
 1145/EB1E : AF                         	XRA	A	;clear record byte in fcb.
 1146/EB1F : 32 ED EB                   	STA	FCB+32
 1147/EB22 : 11 5C 00                   	LXI	D,TFCB	;move it into place at(005Ch).
 1148/EB25 : 21 CD EB                   	LXI	H,FCB
 1149/EB28 : 06 21                      	MVI	B,33
 1150/EB2A : CD 42 E8                   	CALL	HL2DE
 1151/EB2D : 21 08 E4                   	LXI	H,INBUFF+2;now move the remainder of the input
 1152/EB30 : 7E                         UNKWN5	MOV	A,M	;line down to (0080h). Look for a non blank.
 1153/EB31 : B7                         	ORA	A	;or a null.
 1154/EB32 : CA 3E EB                   	JZ	UNKWN6
 1155/EB35 : FE 20                      	CPI	' '
 1156/EB37 : CA 3E EB                   	JZ	UNKWN6
 1157/EB3A : 23                         	INX	H
 1158/EB3B : C3 30 EB                   	JMP	UNKWN5
 1159/EB3E :                            ;
 1160/EB3E :                            ;   Do the line move now. It ends in a null byte.
 1161/EB3E :                            ;
 1162/EB3E : 06 00                      UNKWN6	MVI	B,0	;keep a character count.
 1163/EB40 : 11 81 00                   	LXI	D,TBUFF+1;data gets put here.
 1164/EB43 : 7E                         UNKWN7	MOV	A,M	;move it now.
 1165/EB44 : 12                         	STAX	D
 1166/EB45 : B7                         	ORA	A
 1167/EB46 : CA 4F EB                   	JZ	UNKWN8
 1168/EB49 : 04                         	INR	B
 1169/EB4A : 23                         	INX	H
 1170/EB4B : 13                         	INX	D
 1171/EB4C : C3 43 EB                   	JMP	UNKWN7
 1172/EB4F : 78                         UNKWN8	MOV	A,B	;now store the character count.
 1173/EB50 : 32 80 00                   	STA	TBUFF
 1174/EB53 : CD 98 E4                   	CALL	CRLF	;clean up the screen.
 1175/EB56 : CD D5 E5                   	CALL	STDDMA	;set standard transfer address.
 1176/EB59 : CD 1A E5                   	CALL	SETCDRV	;reset current drive.
 1177/EB5C : CD 00 01                   	CALL	TBASE	;and execute the program.
 1178/EB5F :                            ;
 1179/EB5F :                            ;   Transiant programs return here (or reboot).
 1180/EB5F :                            ;
 1181/EB5F : 31 AB EB                   	LXI	SP,BATCH	;set stack first off.
 1182/EB62 : CD 29 E5                   	CALL	MOVECD	;move current drive into place (TDRIVE).
 1183/EB65 : CD BD E4                   	CALL	DSKSEL	;and reselect it.
 1184/EB68 : C3 82 E7                   	JMP	CMMND1	;back to comand mode.
 1185/EB6B :                            ;
 1186/EB6B :                            ;   Get here if some error occured.
 1187/EB6B :                            ;
 1188/EB6B : CD 66 E8                   UNKWN9	CALL	RESETDR	;inproper format.
 1189/EB6E : C3 09 E6                   	JMP	SYNERR
 1190/EB71 : 01 7A EB                   UNKWN0	LXI	B,BADLOAD;read error or won't fit.
 1191/EB74 : CD A7 E4                   	CALL	PLINE
 1192/EB77 : C3 86 EB                   	JMP	GETBACK
 1193/EB7A : 42 61 64 20 6C 6F 61 64 00 BADLOAD	DB	'Bad load',0
 1194/EB83 : 43 4F 4D                   COMFILE	DB	'COM'	;command file extension.
 1195/EB86 :                            ;
 1196/EB86 :                            ;   Get here to return to command level. We will reset the
 1197/EB86 :                            ; previous active drive and then either return to command
 1198/EB86 :                            ; level directly or print error message and then return.
 1199/EB86 :                            ;
 1200/EB86 : CD 66 E8                   GETBACK	CALL	RESETDR	;reset previous drive.
 1201/EB89 : CD 5E E6                   GETBACK1:CALL	CONVFST	;convert first name in (FCB).
 1202/EB8C : 3A CE EB                   	LDA	FCB+1	;if this was just a drive change request,
 1203/EB8F : D6 20                      	SUI	' '	;make sure it was valid.
 1204/EB91 : 21 F0 EB                   	LXI	H,CHGDRV
 1205/EB94 : B6                         	ORA	M
 1206/EB95 : C2 09 E6                   	JNZ	SYNERR
 1207/EB98 : C3 82 E7                   	JMP	CMMND1	;ok, return to command level.
 1208/EB9B :                            ;
 1209/EB9B :                            ;   ccp stack area.
 1210/EB9B :                            ;
 1211/EB9B : 00 00 00 00 00 00 00 00 00 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      EBA4 : 00 00 00 00 00 00 00      
 1212/EBAB : =0EBABH                    CCPSTACK:EQU	$	;end of ccp stack area.
 1213/EBAB :                            ;
 1214/EBAB :                            ;   Batch (or SUBMIT) processing information storage.
 1215/EBAB :                            ;
 1216/EBAB : 00                         BATCH	DB	0	;batch mode flag (0=not active).
 1217/EBAC : 00 24 24 24 20 20 20 20 20 BATCHFCB:DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      EBB5 : 53 55 42 00 00 00 00 00 00
      EBBE : 00 00 00 00 00 00 00 00 00
      EBC7 : 00 00 00 00 00 00         
 1218/EBCD :                            ;
 1219/EBCD :                            ;   File control block setup by the CCP.
 1220/EBCD :                            ;
 1221/EBCD : 00 20 20 20 20 20 20 20 20 FCB	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
      EBD6 : 20 20 20 00 00 00 00 00 20
      EBDF : 20 20 20 20 20 20 20 20 20
      EBE8 : 20 00 00 00 00 00         
 1222/EBEE : 00                         RTNCODE	DB	0	;status returned from bdos call.
 1223/EBEF : 00                         CDRIVE	DB	0	;currently active drive.
 1224/EBF0 : 00                         CHGDRV	DB	0	;change in drives flag (0=no change).
 1225/EBF1 : 00 00                      NBYTES	DW	0	;byte counter used by TYPE.
 1226/EBF3 :                            ;
 1227/EBF3 :                            ;   Room for expansion?
 1228/EBF3 :                            ;
 1229/EBF3 : 00 00 00 00 00 00 00 00 00 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
      EBFC : 00 00 00 00               
 1230/EC00 :                            ;
 1231/EC00 :                            ;   Note that the following six bytes must match those at
 1232/EC00 :                            ; (PATTRN1) or cp/m will HALT. Why?
 1233/EC00 :                            ;
 1234/EC00 : 00 16 00 00 00 00          PATTRN2	DB	0,22,0,0,0,0;(* serial number bytes *).
 1235/EC06 :                            ;
 1236/EC06 :                            ;**************************************************************
 1237/EC06 :                            ;*
 1238/EC06 :                            ;*                    B D O S   E N T R Y
 1239/EC06 :                            ;*
 1240/EC06 :                            ;**************************************************************
 1241/EC06 :                            ;
 1242/EC06 : C3 11 EC                   FBASE	JMP	FBASE1
 1243/EC09 :                            ;
 1244/EC09 :                            ;   Bdos error table.
 1245/EC09 :                            ;
 1246/EC09 : 99 EC                      BADSCTR	DW	ERROR1	;bad sector on read or write.
 1247/EC0B : A5 EC                      BADSLCT	DW	ERROR2	;bad disk select.
 1248/EC0D : AB EC                      RODISK	DW	ERROR3	;disk is read only.
 1249/EC0F : B1 EC                      ROFILE	DW	ERROR4	;file is read only.
 1250/EC11 :                            ;
 1251/EC11 :                            ;   Entry into bdos. (DE) or (E) are the parameters passed. The
 1252/EC11 :                            ; function number desired is in register (C).
 1253/EC11 :                            ;
 1254/EC11 : EB                         FBASE1	XCHG		;save the (DE) parameters.
 1255/EC12 : 22 43 EF                   	SHLD	PARAMS
 1256/EC15 : EB                         	XCHG
 1257/EC16 : 7B                         	MOV	A,E	;and save register (E) in particular.
 1258/EC17 : 32 D6 F9                   	STA	EPARAM
 1259/EC1A : 21 00 00                   	LXI	H,0
 1260/EC1D : 22 45 EF                   	SHLD	STATUS	;clear return status.
 1261/EC20 : 39                         	DAD	SP
 1262/EC21 : 22 0F EF                   	SHLD	USRSTACK;save users stack pointer.
 1263/EC24 : 31 41 EF                   	LXI	SP,STKAREA;and set our own.
 1264/EC27 : AF                         	XRA	A	;clear auto select storage space.
 1265/EC28 : 32 E0 F9                   	STA	AUTOFLAG
 1266/EC2B : 32 DE F9                   	STA	AUTO
 1267/EC2E : 21 74 F9                   	LXI	H,GOBACK;set return address.
 1268/EC31 : E5                         	PUSH	H
 1269/EC32 : 79                         	MOV	A,C	;get function number.
 1270/EC33 : FE 29                      	CPI	NFUNCTS	;valid function number?
 1271/EC35 : D0                         	RNC
 1272/EC36 : 4B                         	MOV	C,E	;keep single register function here.
 1273/EC37 : 21 47 EC                   	LXI	H,FUNCTNS;now look thru the function table.
 1274/EC3A : 5F                         	MOV	E,A
 1275/EC3B : 16 00                      	MVI	D,0	;(DE)=function number.
 1276/EC3D : 19                         	DAD	D
 1277/EC3E : 19                         	DAD	D	;(HL)=(start of table)+2*(function number).
 1278/EC3F : 5E                         	MOV	E,M
 1279/EC40 : 23                         	INX	H
 1280/EC41 : 56                         	MOV	D,M	;now (DE)=address for this function.
 1281/EC42 : 2A 43 EF                   	LHLD	PARAMS	;retrieve parameters.
 1282/EC45 : EB                         	XCHG		;now (DE) has the original parameters.
 1283/EC46 : E9                         	PCHL		;execute desired function.
 1284/EC47 :                            ;
 1285/EC47 :                            ;   BDOS function jump table.
 1286/EC47 :                            ;
 1287/EC47 : =29H                       NFUNCTS	EQU	41	;number of functions in followin table.
 1288/EC47 :                            ;
 1289/EC47 : 03 FA C8 EE 90 ED CE EE 12 FUNCTNS	DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
      EC50 : FA 0F FA D4 EE ED EE      
 1290/EC57 : F3 EE F8 EE E1 ED FE EE 7E 	DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
      EC60 : F8 83 F8 45 F8 9C F8      
 1291/EC67 : A5 F8 AB F8 C8 F8 D7 F8 E0 	DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
      EC70 : F8 E6 F8 EC F8            
 1292/EC75 : F5 F8 FE F8 04 F9 0A F9 11 	DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
      EC7E : F9 2C F1 17 F9 1D F9      
 1293/EC85 : 26 F9 2D F9 41 F9 47 F9 4D 	DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
      EC8E : F9 0E F8 53 F9 04 EF      
 1294/EC95 : 04 EF 9B F9                	DW	RTN,WTSPECL
 1295/EC99 :                            ;
 1296/EC99 :                            ;   Bdos error message section.
 1297/EC99 :                            ;
 1298/EC99 : 21 CA EC                   ERROR1	LXI	H,BADSEC	;bad sector message.
 1299/EC9C : CD E5 EC                   	CALL	PRTERR	;print it and get a 1 char responce.
 1300/EC9F : FE 03                      	CPI	CNTRLC	;re-boot request (control-c)?
 1301/ECA1 : CA 00 00                   	JZ	0	;yes.
 1302/ECA4 : C9                         	RET		;no, return to retry i/o function.
 1303/ECA5 :                            ;
 1304/ECA5 : 21 D5 EC                   ERROR2	LXI	H,BADSEL	;bad drive selected.
 1305/ECA8 : C3 B4 EC                   	JMP	ERROR5
 1306/ECAB :                            ;
 1307/ECAB : 21 E1 EC                   ERROR3	LXI	H,DISKRO	;disk is read only.
 1308/ECAE : C3 B4 EC                   	JMP	ERROR5
 1309/ECB1 :                            ;
 1310/ECB1 : 21 DC EC                   ERROR4	LXI	H,FILERO	;file is read only.
 1311/ECB4 :                            ;
 1312/ECB4 : CD E5 EC                   ERROR5	CALL	PRTERR
 1313/ECB7 : C3 00 00                   	JMP	0	;always reboot on these errors.
 1314/ECBA :                            ;
 1315/ECBA : 42 64 6F 73 20 45 72 72 20 BDOSERR	DB	'Bdos Err On '
      ECC3 : 4F 6E 20                  
 1316/ECC6 : 20 3A 20 24                BDOSDRV	DB	' : $'
 1317/ECCA : 42 61 64 20 53 65 63 74 6F BADSEC	DB	'Bad Sector$'
      ECD3 : 72 24                     
 1318/ECD5 : 53 65 6C 65 63 74 24       BADSEL	DB	'Select$'
 1319/ECDC : 46 69 6C 65 20             FILERO	DB	'File '
 1320/ECE1 : 52 2F 4F 24                DISKRO	DB	'R/O$'
 1321/ECE5 :                            ;
 1322/ECE5 :                            ;   Print bdos error message.
 1323/ECE5 :                            ;
 1324/ECE5 : E5                         PRTERR	PUSH	H	;save second message pointer.
 1325/ECE6 : CD C9 ED                   	CALL	OUTCRLF	;send (cr)(lf).
 1326/ECE9 : 3A 42 EF                   	LDA	ACTIVE	;get active drive.
 1327/ECEC : C6 41                      	ADI	'A'	;make ascii.
 1328/ECEE : 32 C6 EC                   	STA	BDOSDRV	;and put in message.
 1329/ECF1 : 01 BA EC                   	LXI	B,BDOSERR;and print it.
 1330/ECF4 : CD D3 ED                   	CALL	PRTMESG
 1331/ECF7 : C1                         	POP	B	;print second message line now.
 1332/ECF8 : CD D3 ED                   	CALL	PRTMESG
 1333/ECFB :                            ;
 1334/ECFB :                            ;   Get an input character. We will check our 1 character
 1335/ECFB :                            ; buffer first. This may be set by the console status routine.
 1336/ECFB :                            ;
 1337/ECFB : 21 0E EF                   GETCHAR	LXI	H,CHARBUF;check character buffer.
 1338/ECFE : 7E                         	MOV	A,M	;anything present already?
 1339/ECFF : 36 00                      	MVI	M,0	;...either case clear it.
 1340/ED01 : B7                         	ORA	A
 1341/ED02 : C0                         	RNZ		;yes, use it.
 1342/ED03 : C3 09 FA                   	JMP	CONIN	;nope, go get a character responce.
 1343/ED06 :                            ;
 1344/ED06 :                            ;   Input and echo a character.
 1345/ED06 :                            ;
 1346/ED06 : CD FB EC                   GETECHO	CALL	GETCHAR	;input a character.
 1347/ED09 : CD 14 ED                   	CALL	CHKCHAR	;carriage control?
 1348/ED0C : D8                         	RC		;no, a regular control char so don't echo.
 1349/ED0D : F5                         	PUSH	PSW	;ok, save character now.
 1350/ED0E : 4F                         	MOV	C,A
 1351/ED0F : CD 90 ED                   	CALL	OUTCON	;and echo it.
 1352/ED12 : F1                         	POP	PSW	;get character and return.
 1353/ED13 : C9                         	RET
 1354/ED14 :                            ;
 1355/ED14 :                            ;   Check character in (A). Set the zero flag on a carriage
 1356/ED14 :                            ; control character and the carry flag on any other control
 1357/ED14 :                            ; character.
 1358/ED14 :                            ;
 1359/ED14 : FE 0D                      CHKCHAR	CPI	CR	;check for carriage return, line feed, backspace,
 1360/ED16 : C8                         	RZ		;or a tab.
 1361/ED17 : FE 0A                      	CPI	LF
 1362/ED19 : C8                         	RZ
 1363/ED1A : FE 09                      	CPI	TAB
 1364/ED1C : C8                         	RZ
 1365/ED1D : FE 08                      	CPI	BS
 1366/ED1F : C8                         	RZ
 1367/ED20 : FE 20                      	CPI	' '	;other control char? Set carry flag.
 1368/ED22 : C9                         	RET
 1369/ED23 :                            ;
 1370/ED23 :                            ;   Check the console during output. Halt on a control-s, then
 1371/ED23 :                            ; reboot on a control-c. If anything else is ready, clear the
 1372/ED23 :                            ; zero flag and return (the calling routine may want to do
 1373/ED23 :                            ; something).
 1374/ED23 :                            ;
 1375/ED23 : 3A 0E EF                   CKCONSOL:LDA	CHARBUF	;check buffer.
 1376/ED26 : B7                         	ORA	A	;if anything, just return without checking.
 1377/ED27 : C2 45 ED                   	JNZ	CKCON2
 1378/ED2A : CD 06 FA                   	CALL	CONST	;nothing in buffer. Check console.
 1379/ED2D : E6 01                      	ANI	01H	;look at bit 0.
 1380/ED2F : C8                         	RZ		;return if nothing.
 1381/ED30 : CD 09 FA                   	CALL	CONIN	;ok, get it.
 1382/ED33 : FE 13                      	CPI	CNTRLS	;if not control-s, return with zero cleared.
 1383/ED35 : C2 42 ED                   	JNZ	CKCON1
 1384/ED38 : CD 09 FA                   	CALL	CONIN	;halt processing until another char
 1385/ED3B : FE 03                      	CPI	CNTRLC	;is typed. Control-c?
 1386/ED3D : CA 00 00                   	JZ	0	;yes, reboot now.
 1387/ED40 : AF                         	XRA	A	;no, just pretend nothing was ever ready.
 1388/ED41 : C9                         	RET
 1389/ED42 : 32 0E EF                   CKCON1	STA	CHARBUF	;save character in buffer for later processing.
 1390/ED45 : 3E 01                      CKCON2	MVI	A,1	;set (A) to non zero to mean something is ready.
 1391/ED47 : C9                         	RET
 1392/ED48 :                            ;
 1393/ED48 :                            ;   Output (C) to the screen. If the printer flip-flop flag
 1394/ED48 :                            ; is set, we will send character to printer also. The console
 1395/ED48 :                            ; will be checked in the process.
 1396/ED48 :                            ;
 1397/ED48 : 3A 0A EF                   OUTCHAR	LDA	OUTFLAG	;check output flag.
 1398/ED4B : B7                         	ORA	A	;anything and we won't generate output.
 1399/ED4C : C2 62 ED                   	JNZ	OUTCHR1
 1400/ED4F : C5                         	PUSH	B
 1401/ED50 : CD 23 ED                   	CALL	CKCONSOL;check console (we don't care whats there).
 1402/ED53 : C1                         	POP	B
 1403/ED54 : C5                         	PUSH	B
 1404/ED55 : CD 0C FA                   	CALL	CONOUT	;output (C) to the screen.
 1405/ED58 : C1                         	POP	B
 1406/ED59 : C5                         	PUSH	B
 1407/ED5A : 3A 0D EF                   	LDA	PRTFLAG	;check printer flip-flop flag.
 1408/ED5D : B7                         	ORA	A
 1409/ED5E : C4 0F FA                   	CNZ	LIST	;print it also if non-zero.
 1410/ED61 : C1                         	POP	B
 1411/ED62 : 79                         OUTCHR1	MOV	A,C	;update cursors position.
 1412/ED63 : 21 0C EF                   	LXI	H,CURPOS
 1413/ED66 : FE 7F                      	CPI	DEL	;rubouts don't do anything here.
 1414/ED68 : C8                         	RZ
 1415/ED69 : 34                         	INR	M	;bump line pointer.
 1416/ED6A : FE 20                      	CPI	' '	;and return if a normal character.
 1417/ED6C : D0                         	RNC
 1418/ED6D : 35                         	DCR	M	;restore and check for the start of the line.
 1419/ED6E : 7E                         	MOV	A,M
 1420/ED6F : B7                         	ORA	A
 1421/ED70 : C8                         	RZ		;ingnore control characters at the start of the line.
 1422/ED71 : 79                         	MOV	A,C
 1423/ED72 : FE 08                      	CPI	BS	;is it a backspace?
 1424/ED74 : C2 79 ED                   	JNZ	OUTCHR2
 1425/ED77 : 35                         	DCR	M	;yes, backup pointer.
 1426/ED78 : C9                         	RET
 1427/ED79 : FE 0A                      OUTCHR2	CPI	LF	;is it a line feed?
 1428/ED7B : C0                         	RNZ		;ignore anything else.
 1429/ED7C : 36 00                      	MVI	M,0	;reset pointer to start of line.
 1430/ED7E : C9                         	RET
 1431/ED7F :                            ;
 1432/ED7F :                            ;   Output (A) to the screen. If it is a control character
 1433/ED7F :                            ; (other than carriage control), use ^x format.
 1434/ED7F :                            ;
 1435/ED7F : 79                         SHOWIT	MOV	A,C
 1436/ED80 : CD 14 ED                   	CALL	CHKCHAR	;check character.
 1437/ED83 : D2 90 ED                   	JNC	OUTCON	;not a control, use normal output.
 1438/ED86 : F5                         	PUSH	PSW
 1439/ED87 : 0E 5E                      	MVI	C,'^'	;for a control character, preceed it with '^'.
 1440/ED89 : CD 48 ED                   	CALL	OUTCHAR
 1441/ED8C : F1                         	POP	PSW
 1442/ED8D : F6 40                      	ORI	'@'	;and then use the letter equivelant.
 1443/ED8F : 4F                         	MOV	C,A
 1444/ED90 :                            ;
 1445/ED90 :                            ;   Function to output (C) to the console device and expand tabs
 1446/ED90 :                            ; if necessary.
 1447/ED90 :                            ;
 1448/ED90 : 79                         OUTCON	MOV	A,C
 1449/ED91 : FE 09                      	CPI	TAB	;is it a tab?
 1450/ED93 : C2 48 ED                   	JNZ	OUTCHAR	;use regular output.
 1451/ED96 : 0E 20                      OUTCON1	MVI	C,' '	;yes it is, use spaces instead.
 1452/ED98 : CD 48 ED                   	CALL	OUTCHAR
 1453/ED9B : 3A 0C EF                   	LDA	CURPOS	;go until the cursor is at a multiple of 8
 1454/ED9E :                            
 1455/ED9E : E6 07                      	ANI	07H	;position.
 1456/EDA0 : C2 96 ED                   	JNZ	OUTCON1
 1457/EDA3 : C9                         	RET
 1458/EDA4 :                            ;
 1459/EDA4 :                            ;   Echo a backspace character. Erase the prevoius character
 1460/EDA4 :                            ; on the screen.
 1461/EDA4 :                            ;
 1462/EDA4 : CD AC ED                   BACKUP	CALL	BACKUP1	;backup the screen 1 place.
 1463/EDA7 : 0E 20                      	MVI	C,' '	;then blank that character.
 1464/EDA9 : CD 0C FA                   	CALL	CONOUT
 1465/EDAC : 0E 08                      BACKUP1	MVI	C,BS	;then back space once more.
 1466/EDAE : C3 0C FA                   	JMP	CONOUT
 1467/EDB1 :                            ;
 1468/EDB1 :                            ;   Signal a deleted line. Print a '#' at the end and start
 1469/EDB1 :                            ; over.
 1470/EDB1 :                            ;
 1471/EDB1 : 0E 23                      NEWLINE	MVI	C,'#'
 1472/EDB3 : CD 48 ED                   	CALL	OUTCHAR	;print this.
 1473/EDB6 : CD C9 ED                   	CALL	OUTCRLF	;start new line.
 1474/EDB9 : 3A 0C EF                   NEWLN1	LDA	CURPOS	;move the cursor to the starting position.
 1475/EDBC : 21 0B EF                   	LXI	H,STARTING
 1476/EDBF : BE                         	CMP	M
 1477/EDC0 : D0                         	RNC		;there yet?
 1478/EDC1 : 0E 20                      	MVI	C,' '
 1479/EDC3 : CD 48 ED                   	CALL	OUTCHAR	;nope, keep going.
 1480/EDC6 : C3 B9 ED                   	JMP	NEWLN1
 1481/EDC9 :                            ;
 1482/EDC9 :                            ;   Output a (cr) (lf) to the console device (screen).
 1483/EDC9 :                            ;
 1484/EDC9 : 0E 0D                      OUTCRLF	MVI	C,CR
 1485/EDCB : CD 48 ED                   	CALL	OUTCHAR
 1486/EDCE : 0E 0A                      	MVI	C,LF
 1487/EDD0 : C3 48 ED                   	JMP	OUTCHAR
 1488/EDD3 :                            ;
 1489/EDD3 :                            ;   Print message pointed to by (BC). It will end with a '$'.
 1490/EDD3 :                            ;
 1491/EDD3 : 0A                         PRTMESG	LDAX	B	;check for terminating character.
 1492/EDD4 : FE 24                      	CPI	'$'
 1493/EDD6 : C8                         	RZ
 1494/EDD7 : 03                         	INX	B
 1495/EDD8 : C5                         	PUSH	B	;otherwise, bump pointer and print it.
 1496/EDD9 : 4F                         	MOV	C,A
 1497/EDDA : CD 90 ED                   	CALL	OUTCON
 1498/EDDD : C1                         	POP	B
 1499/EDDE : C3 D3 ED                   	JMP	PRTMESG
 1500/EDE1 :                            ;
 1501/EDE1 :                            ;   Function to execute a buffered read.
 1502/EDE1 :                            ;
 1503/EDE1 : 3A 0C EF                   RDBUFF	LDA	CURPOS	;use present location as starting one.
 1504/EDE4 : 32 0B EF                   	STA	STARTING
 1505/EDE7 : 2A 43 EF                   	LHLD	PARAMS	;get the maximum buffer space.
 1506/EDEA : 4E                         	MOV	C,M
 1507/EDEB : 23                         	INX	H	;point to first available space.
 1508/EDEC : E5                         	PUSH	H	;and save.
 1509/EDED : 06 00                      	MVI	B,0	;keep a character count.
 1510/EDEF : C5                         RDBUF1	PUSH	B
 1511/EDF0 : E5                         	PUSH	H
 1512/EDF1 : CD FB EC                   RDBUF2	CALL	GETCHAR	;get the next input character.
 1513/EDF4 : E6 7F                      	ANI	7FH	;strip bit 7.
 1514/EDF6 : E1                         	POP	H	;reset registers.
 1515/EDF7 : C1                         	POP	B
 1516/EDF8 : FE 0D                      	CPI	CR	;en of the line?
 1517/EDFA : CA C1 EE                   	JZ	RDBUF17
 1518/EDFD : FE 0A                      	CPI	LF
 1519/EDFF : CA C1 EE                   	JZ	RDBUF17
 1520/EE02 : FE 08                      	CPI	BS	;how about a backspace?
 1521/EE04 : C2 16 EE                   	JNZ	RDBUF3
 1522/EE07 : 78                         	MOV	A,B	;yes, but ignore at the beginning of the line.
 1523/EE08 : B7                         	ORA	A
 1524/EE09 : CA EF ED                   	JZ	RDBUF1
 1525/EE0C : 05                         	DCR	B	;ok, update counter.
 1526/EE0D : 3A 0C EF                   	LDA	CURPOS	;if we backspace to the start of the line,
 1527/EE10 : 32 0A EF                   	STA	OUTFLAG	;treat as a cancel (control-x).
 1528/EE13 : C3 70 EE                   	JMP	RDBUF10
 1529/EE16 : FE 7F                      RDBUF3	CPI	DEL	;user typed a rubout?
 1530/EE18 : C2 26 EE                   	JNZ	RDBUF4
 1531/EE1B : 78                         	MOV	A,B	;ignore at the start of the line.
 1532/EE1C : B7                         	ORA	A
 1533/EE1D : CA EF ED                   	JZ	RDBUF1
 1534/EE20 : 7E                         	MOV	A,M	;ok, echo the prevoius character.
 1535/EE21 : 05                         	DCR	B	;and reset pointers (counters).
 1536/EE22 : 2B                         	DCX	H
 1537/EE23 : C3 A9 EE                   	JMP	RDBUF15
 1538/EE26 : FE 05                      RDBUF4	CPI	CNTRLE	;physical end of line?
 1539/EE28 : C2 37 EE                   	JNZ	RDBUF5
 1540/EE2B : C5                         	PUSH	B	;yes, do it.
 1541/EE2C : E5                         	PUSH	H
 1542/EE2D : CD C9 ED                   	CALL	OUTCRLF
 1543/EE30 : AF                         	XRA	A	;and update starting position.
 1544/EE31 : 32 0B EF                   	STA	STARTING
 1545/EE34 : C3 F1 ED                   	JMP	RDBUF2
 1546/EE37 : FE 10                      RDBUF5	CPI	CNTRLP	;control-p?
 1547/EE39 : C2 48 EE                   	JNZ	RDBUF6
 1548/EE3C : E5                         	PUSH	H	;yes, flip the print flag filp-flop byte.
 1549/EE3D : 21 0D EF                   	LXI	H,PRTFLAG
 1550/EE40 : 3E 01                      	MVI	A,1	;PRTFLAG=1-PRTFLAG
 1551/EE42 : 96                         	SUB	M
 1552/EE43 : 77                         	MOV	M,A
 1553/EE44 : E1                         	POP	H
 1554/EE45 : C3 EF ED                   	JMP	RDBUF1
 1555/EE48 : FE 18                      RDBUF6	CPI	CNTRLX	;control-x (cancel)?
 1556/EE4A : C2 5F EE                   	JNZ	RDBUF8
 1557/EE4D : E1                         	POP	H
 1558/EE4E : 3A 0B EF                   RDBUF7	LDA	STARTING;yes, backup the cursor to here.
 1559/EE51 : 21 0C EF                   	LXI	H,CURPOS
 1560/EE54 : BE                         	CMP	M
 1561/EE55 : D2 E1 ED                   	JNC	RDBUFF	;done yet?
 1562/EE58 : 35                         	DCR	M	;no, decrement pointer and output back up one space.
 1563/EE59 : CD A4 ED                   	CALL	BACKUP
 1564/EE5C : C3 4E EE                   	JMP	RDBUF7
 1565/EE5F : FE 15                      RDBUF8	CPI	CNTRLU	;cntrol-u (cancel line)?
 1566/EE61 : C2 6B EE                   	JNZ	RDBUF9
 1567/EE64 : CD B1 ED                   	CALL	NEWLINE	;start a new line.
 1568/EE67 : E1                         	POP	H
 1569/EE68 : C3 E1 ED                   	JMP	RDBUFF
 1570/EE6B : FE 12                      RDBUF9	CPI	CNTRLR	;control-r?
 1571/EE6D : C2 A6 EE                   	JNZ	RDBUF14
 1572/EE70 : C5                         RDBUF10	PUSH	B	;yes, start a new line and retype the old one.
 1573/EE71 : CD B1 ED                   	CALL	NEWLINE
 1574/EE74 : C1                         	POP	B
 1575/EE75 : E1                         	POP	H
 1576/EE76 : E5                         	PUSH	H
 1577/EE77 : C5                         	PUSH	B
 1578/EE78 : 78                         RDBUF11	MOV	A,B	;done whole line yet?
 1579/EE79 : B7                         	ORA	A
 1580/EE7A : CA 8A EE                   	JZ	RDBUF12
 1581/EE7D : 23                         	INX	H	;nope, get next character.
 1582/EE7E : 4E                         	MOV	C,M
 1583/EE7F : 05                         	DCR	B	;count it.
 1584/EE80 : C5                         	PUSH	B
 1585/EE81 : E5                         	PUSH	H
 1586/EE82 : CD 7F ED                   	CALL	SHOWIT	;and display it.
 1587/EE85 : E1                         	POP	H
 1588/EE86 : C1                         	POP	B
 1589/EE87 : C3 78 EE                   	JMP	RDBUF11
 1590/EE8A : E5                         RDBUF12	PUSH	H	;done with line. If we were displaying
 1591/EE8B : 3A 0A EF                   	LDA	OUTFLAG	;then update cursor position.
 1592/EE8E : B7                         	ORA	A
 1593/EE8F : CA F1 ED                   	JZ	RDBUF2
 1594/EE92 : 21 0C EF                   	LXI	H,CURPOS;because this line is shorter, we must
 1595/EE95 : 96                         	SUB	M	;back up the cursor (not the screen however)
 1596/EE96 : 32 0A EF                   	STA	OUTFLAG	;some number of positions.
 1597/EE99 : CD A4 ED                   RDBUF13	CALL	BACKUP	;note that as long as (OUTFLAG) is non
 1598/EE9C : 21 0A EF                   	LXI	H,OUTFLAG;zero, the screen will not be changed.
 1599/EE9F : 35                         	DCR	M
 1600/EEA0 : C2 99 EE                   	JNZ	RDBUF13
 1601/EEA3 : C3 F1 ED                   	JMP	RDBUF2	;now just get the next character.
 1602/EEA6 :                            ;
 1603/EEA6 :                            ;   Just a normal character, put this in our buffer and echo.
 1604/EEA6 :                            ;
 1605/EEA6 : 23                         RDBUF14	INX	H
 1606/EEA7 : 77                         	MOV	M,A	;store character.
 1607/EEA8 : 04                         	INR	B	;and count it.
 1608/EEA9 : C5                         RDBUF15	PUSH	B
 1609/EEAA : E5                         	PUSH	H
 1610/EEAB : 4F                         	MOV	C,A	;echo it now.
 1611/EEAC : CD 7F ED                   	CALL	SHOWIT
 1612/EEAF : E1                         	POP	H
 1613/EEB0 : C1                         	POP	B
 1614/EEB1 : 7E                         	MOV	A,M	;was it an abort request?
 1615/EEB2 : FE 03                      	CPI	CNTRLC	;control-c abort?
 1616/EEB4 : 78                         	MOV	A,B
 1617/EEB5 : C2 BD EE                   	JNZ	RDBUF16
 1618/EEB8 : FE 01                      	CPI	1	;only if at start of line.
 1619/EEBA : CA 00 00                   	JZ	0
 1620/EEBD : B9                         RDBUF16	CMP	C	;nope, have we filled the buffer?
 1621/EEBE : DA EF ED                   	JC	RDBUF1
 1622/EEC1 : E1                         RDBUF17	POP	H	;yes end the line and return.
 1623/EEC2 : 70                         	MOV	M,B
 1624/EEC3 : 0E 0D                      	MVI	C,CR
 1625/EEC5 : C3 48 ED                   	JMP	OUTCHAR	;output (cr) and return.
 1626/EEC8 :                            ;
 1627/EEC8 :                            ;   Function to get a character from the console device.
 1628/EEC8 :                            ;
 1629/EEC8 : CD 06 ED                   GETCON	CALL	GETECHO	;get and echo.
 1630/EECB : C3 01 EF                   	JMP	SETSTAT	;save status and return.
 1631/EECE :                            ;
 1632/EECE :                            ;   Function to get a character from the tape reader device.
 1633/EECE :                            ;
 1634/EECE : CD 15 FA                   GETRDR	CALL	READER	;get a character from reader, set status and return.
 1635/EED1 : C3 01 EF                   	JMP	SETSTAT
 1636/EED4 :                            ;
 1637/EED4 :                            ;  Function to perform direct console i/o. If (C) contains (FF)
 1638/EED4 :                            ; then this is an input request. If (C) contains (FE) then
 1639/EED4 :                            ; this is a status request. Otherwise we are to output (C).
 1640/EED4 :                            ;
 1641/EED4 : 79                         DIRCIO	MOV	A,C	;test for (FF).
 1642/EED5 : 3C                         	INR	A
 1643/EED6 : CA E0 EE                   	JZ	DIRC1
 1644/EED9 : 3C                         	INR	A	;test for (FE).
 1645/EEDA : CA 06 FA                   	JZ	CONST
 1646/EEDD : C3 0C FA                   	JMP	CONOUT	;just output (C).
 1647/EEE0 : CD 06 FA                   DIRC1	CALL	CONST	;this is an input request.
 1648/EEE3 : B7                         	ORA	A
 1649/EEE4 : CA 91 F9                   	JZ	GOBACK1	;not ready? Just return (directly).
 1650/EEE7 : CD 09 FA                   	CALL	CONIN	;yes, get character.
 1651/EEEA : C3 01 EF                   	JMP	SETSTAT	;set status and return.
 1652/EEED :                            ;
 1653/EEED :                            ;   Function to return the i/o byte.
 1654/EEED :                            ;
 1655/EEED : 3A 03 00                   GETIOB	LDA	IOBYTE
 1656/EEF0 : C3 01 EF                   	JMP	SETSTAT
 1657/EEF3 :                            ;
 1658/EEF3 :                            ;   Function to set the i/o byte.
 1659/EEF3 :                            ;
 1660/EEF3 : 21 03 00                   SETIOB	LXI	H,IOBYTE
 1661/EEF6 : 71                         	MOV	M,C
 1662/EEF7 : C9                         	RET
 1663/EEF8 :                            ;
 1664/EEF8 :                            ;   Function to print the character string pointed to by (DE)
 1665/EEF8 :                            ; on the console device. The string ends with a '$'.
 1666/EEF8 :                            ;
 1667/EEF8 : EB                         PRTSTR	XCHG
 1668/EEF9 : 4D                         	MOV	C,L
 1669/EEFA : 44                         	MOV	B,H	;now (BC) points to it.
 1670/EEFB : C3 D3 ED                   	JMP	PRTMESG
 1671/EEFE :                            ;
 1672/EEFE :                            ;   Function to interigate the console device.
 1673/EEFE :                            ;
 1674/EEFE : CD 23 ED                   GETCSTS	CALL	CKCONSOL
 1675/EF01 :                            ;
 1676/EF01 :                            ;   Get here to set the status and return to the cleanup
 1677/EF01 :                            ; section. Then back to the user.
 1678/EF01 :                            ;
 1679/EF01 : 32 45 EF                   SETSTAT	STA	STATUS
 1680/EF04 : C9                         RTN	RET
 1681/EF05 :                            ;
 1682/EF05 :                            ;   Set the status to 1 (read or write error code).
 1683/EF05 :                            ;
 1684/EF05 : 3E 01                      IOERR1	MVI	A,1
 1685/EF07 : C3 01 EF                   	JMP	SETSTAT
 1686/EF0A :                            ;
 1687/EF0A : 00                         OUTFLAG	DB	0	;output flag (non zero means no output).
 1688/EF0B : 02                         STARTING:DB	2	;starting position for cursor.
 1689/EF0C : 00                         CURPOS	DB	0	;cursor position (0=start of line).
 1690/EF0D : 00                         PRTFLAG	DB	0	;printer flag (control-p toggle). List if non zero.
 1691/EF0E : 00                         CHARBUF	DB	0	;single input character buffer.
 1692/EF0F :                            ;
 1693/EF0F :                            ;   Stack area for BDOS calls.
 1694/EF0F :                            ;
 1695/EF0F : 00 00                      USRSTACK:DW	0	;save users stack pointer here.
 1696/EF11 :                            ;
 1697/EF11 : 00 00 00 00 00 00 00 00 00 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      EF1A : 00 00 00 00 00 00 00 00 00
      EF23 : 00 00 00 00 00 00         
 1698/EF29 : 00 00 00 00 00 00 00 00 00 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      EF32 : 00 00 00 00 00 00 00 00 00
      EF3B : 00 00 00 00 00 00         
 1699/EF41 : =0EF41H                    STKAREA	EQU	$	;end of stack area.
 1700/EF41 :                            ;
 1701/EF41 : 00                         USERNO	DB	0	;current user number.
 1702/EF42 : 00                         ACTIVE	DB	0	;currently active drive.
 1703/EF43 : 00 00                      PARAMS	DW	0	;save (DE) parameters here on entry.
 1704/EF45 : 00 00                      STATUS	DW	0	;status returned from bdos function.
 1705/EF47 :                            ;
 1706/EF47 :                            ;   Select error occured, jump to error routine.
 1707/EF47 :                            ;
 1708/EF47 : 21 0B EC                   SLCTERR	LXI	H,BADSLCT
 1709/EF4A :                            ;
 1710/EF4A :                            ;   Jump to (HL) indirectly.
 1711/EF4A :                            ;
 1712/EF4A : 5E                         JUMPHL	MOV	E,M
 1713/EF4B : 23                         	INX	H
 1714/EF4C : 56                         	MOV	D,M	;now (DE) contain the desired address.
 1715/EF4D : EB                         	XCHG
 1716/EF4E : E9                         	PCHL
 1717/EF4F :                            ;
 1718/EF4F :                            ;   Block move. (DE) to (HL), (C) bytes total.
 1719/EF4F :                            ;
 1720/EF4F : 0C                         DE2HL	INR	C	;is count down to zero?
 1721/EF50 : 0D                         DE2HL1	DCR	C
 1722/EF51 : C8                         	RZ		;yes, we are done.
 1723/EF52 : 1A                         	LDAX	D	;no, move one more byte.
 1724/EF53 : 77                         	MOV	M,A
 1725/EF54 : 13                         	INX	D
 1726/EF55 : 23                         	INX	H
 1727/EF56 : C3 50 EF                   	JMP	DE2HL1	;and repeat.
 1728/EF59 :                            ;
 1729/EF59 :                            ;   Select the desired drive.
 1730/EF59 :                            ;
 1731/EF59 : 3A 42 EF                   SELECT	LDA	ACTIVE	;get active disk.
 1732/EF5C : 4F                         	MOV	C,A
 1733/EF5D : CD 1B FA                   	CALL	SELDSK	;select it.
 1734/EF60 : 7C                         	MOV	A,H	;valid drive?
 1735/EF61 : B5                         	ORA	L	;valid drive?
 1736/EF62 : C8                         	RZ		;return if not.
 1737/EF63 :                            ;
 1738/EF63 :                            ;   Here, the BIOS returned the address of the parameter block
 1739/EF63 :                            ; in (HL). We will extract the necessary pointers and save them.
 1740/EF63 :                            ;
 1741/EF63 : 5E                         	MOV	E,M	;yes, get address of translation table into (DE).
 1742/EF64 : 23                         	INX	H
 1743/EF65 : 56                         	MOV	D,M
 1744/EF66 : 23                         	INX	H
 1745/EF67 : 22 B3 F9                   	SHLD	SCRATCH1	;save pointers to scratch areas.
 1746/EF6A : 23                         	INX	H
 1747/EF6B : 23                         	INX	H
 1748/EF6C : 22 B5 F9                   	SHLD	SCRATCH2	;ditto.
 1749/EF6F : 23                         	INX	H
 1750/EF70 : 23                         	INX	H
 1751/EF71 : 22 B7 F9                   	SHLD	SCRATCH3	;ditto.
 1752/EF74 : 23                         	INX	H
 1753/EF75 : 23                         	INX	H
 1754/EF76 : EB                         	XCHG		;now save the translation table address.
 1755/EF77 : 22 D0 F9                   	SHLD	XLATE
 1756/EF7A : 21 B9 F9                   	LXI	H,DIRBUF	;put the next 8 bytes here.
 1757/EF7D : 0E 08                      	MVI	C,8	;they consist of the directory buffer
 1758/EF7F : CD 4F EF                   	CALL	DE2HL	;pointer, parameter block pointer,
 1759/EF82 : 2A BB F9                   	LHLD	DISKPB	;check and allocation vectors.
 1760/EF85 : EB                         	XCHG
 1761/EF86 : 21 C1 F9                   	LXI	H,SECTORS	;move parameter block into our ram.
 1762/EF89 : 0E 0F                      	MVI	C,15	;it is 15 bytes long.
 1763/EF8B : CD 4F EF                   	CALL	DE2HL
 1764/EF8E : 2A C6 F9                   	LHLD	DSKSIZE	;check disk size.
 1765/EF91 : 7C                         	MOV	A,H	;more than 256 blocks on this?
 1766/EF92 : 21 DD F9                   	LXI	H,BIGDISK
 1767/EF95 : 36 FF                      	MVI	M,0FFH	;set to samll.
 1768/EF97 : B7                         	ORA	A
 1769/EF98 : CA 9D EF                   	JZ	SELECT1
 1770/EF9B : 36 00                      	MVI	M,0	;wrong, set to large.
 1771/EF9D : 3E FF                      SELECT1	MVI	A,0FFH	;clear the zero flag.
 1772/EF9F : B7                         	ORA	A
 1773/EFA0 : C9                         	RET
 1774/EFA1 :                            ;
 1775/EFA1 :                            ;   Routine to home the disk track head and clear pointers.
 1776/EFA1 :                            ;
 1777/EFA1 : CD 18 FA                   HOMEDRV	CALL	HOME	;home the head.
 1778/EFA4 : AF                         	XRA	A
 1779/EFA5 : 2A B5 F9                   	LHLD	SCRATCH2;set our track pointer also.
 1780/EFA8 : 77                         	MOV	M,A
 1781/EFA9 : 23                         	INX	H
 1782/EFAA : 77                         	MOV	M,A
 1783/EFAB : 2A B7 F9                   	LHLD	SCRATCH3;and our sector pointer.
 1784/EFAE : 77                         	MOV	M,A
 1785/EFAF : 23                         	INX	H
 1786/EFB0 : 77                         	MOV	M,A
 1787/EFB1 : C9                         	RET
 1788/EFB2 :                            ;
 1789/EFB2 :                            ;   Do the actual disk read and check the error return status.
 1790/EFB2 :                            ;
 1791/EFB2 : CD 27 FA                   DOREAD	CALL	READ
 1792/EFB5 : C3 BB EF                   	JMP	IORET
 1793/EFB8 :                            ;
 1794/EFB8 :                            ;   Do the actual disk write and handle any bios error.
 1795/EFB8 :                            ;
 1796/EFB8 : CD 2A FA                   DOWRITE	CALL	WRITE
 1797/EFBB : B7                         IORET	ORA	A
 1798/EFBC : C8                         	RZ		;return unless an error occured.
 1799/EFBD : 21 09 EC                   	LXI	H,BADSCTR;bad read/write on this sector.
 1800/EFC0 : C3 4A EF                   	JMP	JUMPHL
 1801/EFC3 :                            ;
 1802/EFC3 :                            ;   Routine to select the track and sector that the desired
 1803/EFC3 :                            ; block number falls in.
 1804/EFC3 :                            ;
 1805/EFC3 : 2A EA F9                   TRKSEC	LHLD	FILEPOS	;get position of last accessed file
 1806/EFC6 : 0E 02                      	MVI	C,2	;in directory and compute sector #.
 1807/EFC8 : CD EA F0                   	CALL	SHIFTR	;sector #=file-position/4.
 1808/EFCB : 22 E5 F9                   	SHLD	BLKNMBR	;save this as the block number of interest.
 1809/EFCE : 22 EC F9                   	SHLD	CKSUMTBL;what's it doing here too?
 1810/EFD1 :                            ;
 1811/EFD1 :                            ;   if the sector number has already been set (BLKNMBR), enter
 1812/EFD1 :                            ; at this point.
 1813/EFD1 :                            ;
 1814/EFD1 : 21 E5 F9                   TRKSEC1	LXI	H,BLKNMBR
 1815/EFD4 : 4E                         	MOV	C,M	;move sector number into (BC).
 1816/EFD5 : 23                         	INX	H
 1817/EFD6 : 46                         	MOV	B,M
 1818/EFD7 : 2A B7 F9                   	LHLD	SCRATCH3;get current sector number and
 1819/EFDA : 5E                         	MOV	E,M	;move this into (DE).
 1820/EFDB : 23                         	INX	H
 1821/EFDC : 56                         	MOV	D,M
 1822/EFDD : 2A B5 F9                   	LHLD	SCRATCH2;get current track number.
 1823/EFE0 : 7E                         	MOV	A,M	;and this into (HL).
 1824/EFE1 : 23                         	INX	H
 1825/EFE2 : 66                         	MOV	H,M
 1826/EFE3 : 6F                         	MOV	L,A
 1827/EFE4 : 79                         TRKSEC2	MOV	A,C	;is desired sector before current one?
 1828/EFE5 : 93                         	SUB	E
 1829/EFE6 : 78                         	MOV	A,B
 1830/EFE7 : 9A                         	SBB	D
 1831/EFE8 : D2 FA EF                   	JNC	TRKSEC3
 1832/EFEB : E5                         	PUSH	H	;yes, decrement sectors by one track.
 1833/EFEC : 2A C1 F9                   	LHLD	SECTORS	;get sectors per track.
 1834/EFEF : 7B                         	MOV	A,E
 1835/EFF0 : 95                         	SUB	L
 1836/EFF1 : 5F                         	MOV	E,A
 1837/EFF2 : 7A                         	MOV	A,D
 1838/EFF3 : 9C                         	SBB	H
 1839/EFF4 : 57                         	MOV	D,A	;now we have backed up one full track.
 1840/EFF5 : E1                         	POP	H
 1841/EFF6 : 2B                         	DCX	H	;adjust track counter.
 1842/EFF7 : C3 E4 EF                   	JMP	TRKSEC2
 1843/EFFA : E5                         TRKSEC3	PUSH	H	;desired sector is after current one.
 1844/EFFB : 2A C1 F9                   	LHLD	SECTORS	;get sectors per track.
 1845/EFFE : 19                         	DAD	D	;bump sector pointer to next track.
 1846/EFFF : DA 0F F0                   	JC	TRKSEC4
 1847/F002 : 79                         	MOV	A,C	;is desired sector now before current one?
 1848/F003 : 95                         	SUB	L
 1849/F004 : 78                         	MOV	A,B
 1850/F005 : 9C                         	SBB	H
 1851/F006 : DA 0F F0                   	JC	TRKSEC4
 1852/F009 : EB                         	XCHG		;not yes, increment track counter
 1853/F00A : E1                         	POP	H	;and continue until it is.
 1854/F00B : 23                         	INX	H
 1855/F00C : C3 FA EF                   	JMP	TRKSEC3
 1856/F00F :                            ;
 1857/F00F :                            ;   here we have determined the track number that contains the
 1858/F00F :                            ; desired sector.
 1859/F00F :                            ;
 1860/F00F : E1                         TRKSEC4	POP	H	;get track number (HL).
 1861/F010 : C5                         	PUSH	B
 1862/F011 : D5                         	PUSH	D
 1863/F012 : E5                         	PUSH	H
 1864/F013 : EB                         	XCHG
 1865/F014 : 2A CE F9                   	LHLD	OFFSET	;adjust for first track offset.
 1866/F017 : 19                         	DAD	D
 1867/F018 : 44                         	MOV	B,H
 1868/F019 : 4D                         	MOV	C,L
 1869/F01A : CD 1E FA                   	CALL	SETTRK	;select this track.
 1870/F01D : D1                         	POP	D	;reset current track pointer.
 1871/F01E : 2A B5 F9                   	LHLD	SCRATCH2
 1872/F021 : 73                         	MOV	M,E
 1873/F022 : 23                         	INX	H
 1874/F023 : 72                         	MOV	M,D
 1875/F024 : D1                         	POP	D
 1876/F025 : 2A B7 F9                   	LHLD	SCRATCH3;reset the first sector on this track.
 1877/F028 : 73                         	MOV	M,E
 1878/F029 : 23                         	INX	H
 1879/F02A : 72                         	MOV	M,D
 1880/F02B : C1                         	POP	B
 1881/F02C : 79                         	MOV	A,C	;now subtract the desired one.
 1882/F02D : 93                         	SUB	E	;to make it relative (1-# sectors/track).
 1883/F02E : 4F                         	MOV	C,A
 1884/F02F : 78                         	MOV	A,B
 1885/F030 : 9A                         	SBB	D
 1886/F031 : 47                         	MOV	B,A
 1887/F032 : 2A D0 F9                   	LHLD	XLATE	;translate this sector according to this table.
 1888/F035 : EB                         	XCHG
 1889/F036 : CD 30 FA                   	CALL	SECTRN	;let the bios translate it.
 1890/F039 : 4D                         	MOV	C,L
 1891/F03A : 44                         	MOV	B,H
 1892/F03B : C3 21 FA                   	JMP	SETSEC	;and select it.
 1893/F03E :                            ;
 1894/F03E :                            ;   Compute block number from record number (SAVNREC) and
 1895/F03E :                            ; extent number (SAVEXT).
 1896/F03E :                            ;
 1897/F03E : 21 C3 F9                   GETBLOCK:LXI	H,BLKSHFT;get logical to physical conversion.
 1898/F041 : 4E                         	MOV	C,M	;note that this is base 2 log of ratio.
 1899/F042 : 3A E3 F9                   	LDA	SAVNREC	;get record number.
 1900/F045 : B7                         GETBLK1	ORA	A	;compute (A)=(A)/2^BLKSHFT.
 1901/F046 : 1F                         	RAR
 1902/F047 : 0D                         	DCR	C
 1903/F048 : C2 45 F0                   	JNZ	GETBLK1
 1904/F04B : 47                         	MOV	B,A	;save result in (B).
 1905/F04C : 3E 08                      	MVI	A,8
 1906/F04E : 96                         	SUB	M
 1907/F04F : 4F                         	MOV	C,A	;compute (C)=8-BLKSHFT.
 1908/F050 : 3A E2 F9                   	LDA	SAVEXT
 1909/F053 : 0D                         GETBLK2	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
 1910/F054 : CA 5C F0                   	JZ	GETBLK3
 1911/F057 : B7                         	ORA	A
 1912/F058 : 17                         	RAL
 1913/F059 : C3 53 F0                   	JMP	GETBLK2
 1914/F05C : 80                         GETBLK3	ADD	B
 1915/F05D : C9                         	RET
 1916/F05E :                            ;
 1917/F05E :                            ;   Routine to extract the (BC) block byte from the fcb pointed
 1918/F05E :                            ; to by (PARAMS). If this is a big-disk, then these are 16 bit
 1919/F05E :                            ; block numbers, else they are 8 bit numbers.
 1920/F05E :                            ; Number is returned in (HL).
 1921/F05E :                            ;
 1922/F05E : 2A 43 EF                   EXTBLK	LHLD	PARAMS	;get fcb address.
 1923/F061 : 11 10 00                   	LXI	D,16	;block numbers start 16 bytes into fcb.
 1924/F064 : 19                         	DAD	D
 1925/F065 : 09                         	DAD	B
 1926/F066 : 3A DD F9                   	LDA	BIGDISK	;are we using a big-disk?
 1927/F069 : B7                         	ORA	A
 1928/F06A : CA 71 F0                   	JZ	EXTBLK1
 1929/F06D : 6E                         	MOV	L,M	;no, extract an 8 bit number from the fcb.
 1930/F06E : 26 00                      	MVI	H,0
 1931/F070 : C9                         	RET
 1932/F071 : 09                         EXTBLK1	DAD	B	;yes, extract a 16 bit number.
 1933/F072 : 5E                         	MOV	E,M
 1934/F073 : 23                         	INX	H
 1935/F074 : 56                         	MOV	D,M
 1936/F075 : EB                         	XCHG		;return in (HL).
 1937/F076 : C9                         	RET
 1938/F077 :                            ;
 1939/F077 :                            ;   Compute block number.
 1940/F077 :                            ;
 1941/F077 : CD 3E F0                   COMBLK	CALL	GETBLOCK
 1942/F07A : 4F                         	MOV	C,A
 1943/F07B : 06 00                      	MVI	B,0
 1944/F07D : CD 5E F0                   	CALL	EXTBLK
 1945/F080 : 22 E5 F9                   	SHLD	BLKNMBR
 1946/F083 : C9                         	RET
 1947/F084 :                            ;
 1948/F084 :                            ;   Check for a zero block number (unused).
 1949/F084 :                            ;
 1950/F084 : 2A E5 F9                   CHKBLK	LHLD	BLKNMBR
 1951/F087 : 7D                         	MOV	A,L	;is it zero?
 1952/F088 : B4                         	ORA	H
 1953/F089 : C9                         	RET
 1954/F08A :                            ;
 1955/F08A :                            ;   Adjust physical block (BLKNMBR) and convert to logical
 1956/F08A :                            ; sector (LOGSECT). This is the starting sector of this block.
 1957/F08A :                            ; The actual sector of interest is then added to this and the
 1958/F08A :                            ; resulting sector number is stored back in (BLKNMBR). This
 1959/F08A :                            ; will still have to be adjusted for the track number.
 1960/F08A :                            ;
 1961/F08A : 3A C3 F9                   LOGICAL	LDA	BLKSHFT	;get log2(physical/logical sectors).
 1962/F08D : 2A E5 F9                   	LHLD	BLKNMBR	;get physical sector desired.
 1963/F090 : 29                         LOGICL1	DAD	H	;compute logical sector number.
 1964/F091 : 3D                         	DCR	A	;note logical sectors are 128 bytes long.
 1965/F092 : C2 90 F0                   	JNZ	LOGICL1
 1966/F095 : 22 E7 F9                   	SHLD	LOGSECT	;save logical sector.
 1967/F098 : 3A C4 F9                   	LDA	BLKMASK	;get block mask.
 1968/F09B : 4F                         	MOV	C,A
 1969/F09C : 3A E3 F9                   	LDA	SAVNREC	;get next sector to access.
 1970/F09F : A1                         	ANA	C	;extract the relative position within physical block.
 1971/F0A0 : B5                         	ORA	L	;and add it too logical sector.
 1972/F0A1 : 6F                         	MOV	L,A
 1973/F0A2 : 22 E5 F9                   	SHLD	BLKNMBR	;and store.
 1974/F0A5 : C9                         	RET
 1975/F0A6 :                            ;
 1976/F0A6 :                            ;   Set (HL) to point to extent byte in fcb.
 1977/F0A6 :                            ;
 1978/F0A6 : 2A 43 EF                   SETEXT	LHLD	PARAMS
 1979/F0A9 : 11 0C 00                   	LXI	D,12	;it is the twelth byte.
 1980/F0AC : 19                         	DAD	D
 1981/F0AD : C9                         	RET
 1982/F0AE :                            ;
 1983/F0AE :                            ;   Set (HL) to point to record count byte in fcb and (DE) to
 1984/F0AE :                            ; next record number byte.
 1985/F0AE :                            ;
 1986/F0AE : 2A 43 EF                   SETHLDE	LHLD	PARAMS
 1987/F0B1 : 11 0F 00                   	LXI	D,15	;record count byte (#15).
 1988/F0B4 : 19                         	DAD	D
 1989/F0B5 : EB                         	XCHG
 1990/F0B6 : 21 11 00                   	LXI	H,17	;next record number (#32).
 1991/F0B9 : 19                         	DAD	D
 1992/F0BA : C9                         	RET
 1993/F0BB :                            ;
 1994/F0BB :                            ;   Save current file data from fcb.
 1995/F0BB :                            ;
 1996/F0BB : CD AE F0                   STRDATA	CALL	SETHLDE
 1997/F0BE : 7E                         	MOV	A,M	;get and store record count byte.
 1998/F0BF : 32 E3 F9                   	STA	SAVNREC
 1999/F0C2 : EB                         	XCHG
 2000/F0C3 : 7E                         	MOV	A,M	;get and store next record number byte.
 2001/F0C4 : 32 E1 F9                   	STA	SAVNXT
 2002/F0C7 : CD A6 F0                   	CALL	SETEXT	;point to extent byte.
 2003/F0CA : 3A C5 F9                   	LDA	EXTMASK	;get extent mask.
 2004/F0CD : A6                         	ANA	M
 2005/F0CE : 32 E2 F9                   	STA	SAVEXT	;and save extent here.
 2006/F0D1 : C9                         	RET
 2007/F0D2 :                            ;
 2008/F0D2 :                            ;   Set the next record to access. If (MODE) is set to 2, then
 2009/F0D2 :                            ; the last record byte (SAVNREC) has the correct number to access.
 2010/F0D2 :                            ; For sequential access, (MODE) will be equal to 1.
 2011/F0D2 :                            ;
 2012/F0D2 : CD AE F0                   SETNREC	CALL	SETHLDE
 2013/F0D5 : 3A D5 F9                   	LDA	MODE	;get sequential flag (=1).
 2014/F0D8 : FE 02                      	CPI	2	;a 2 indicates that no adder is needed.
 2015/F0DA : C2 DE F0                   	JNZ	STNREC1
 2016/F0DD : AF                         	XRA	A	;clear adder (random access?).
 2017/F0DE : 4F                         STNREC1	MOV	C,A
 2018/F0DF : 3A E3 F9                   	LDA	SAVNREC	;get last record number.
 2019/F0E2 : 81                         	ADD	C	;increment record count.
 2020/F0E3 : 77                         	MOV	M,A	;and set fcb's next record byte.
 2021/F0E4 : EB                         	XCHG
 2022/F0E5 : 3A E1 F9                   	LDA	SAVNXT	;get next record byte from storage.
 2023/F0E8 : 77                         	MOV	M,A	;and put this into fcb as number of records used.
 2024/F0E9 : C9                         	RET
 2025/F0EA :                            ;
 2026/F0EA :                            ;   Shift (HL) right (C) bits.
 2027/F0EA :                            ;
 2028/F0EA : 0C                         SHIFTR	INR	C
 2029/F0EB : 0D                         SHIFTR1	DCR	C
 2030/F0EC : C8                         	RZ
 2031/F0ED : 7C                         	MOV	A,H
 2032/F0EE : B7                         	ORA	A
 2033/F0EF : 1F                         	RAR
 2034/F0F0 : 67                         	MOV	H,A
 2035/F0F1 : 7D                         	MOV	A,L
 2036/F0F2 : 1F                         	RAR
 2037/F0F3 : 6F                         	MOV	L,A
 2038/F0F4 : C3 EB F0                   	JMP	SHIFTR1
 2039/F0F7 :                            ;
 2040/F0F7 :                            ;   Compute the check-sum for the directory buffer. Return
 2041/F0F7 :                            ; integer sum in (A).
 2042/F0F7 :                            ;
 2043/F0F7 : 0E 80                      CHECKSUM:MVI	C,128	;length of buffer.
 2044/F0F9 : 2A B9 F9                   	LHLD	DIRBUF	;get its location.
 2045/F0FC : AF                         	XRA	A	;clear summation byte.
 2046/F0FD : 86                         CHKSUM1	ADD	M	;and compute sum ignoring carries.
 2047/F0FE : 23                         	INX	H
 2048/F0FF : 0D                         	DCR	C
 2049/F100 : C2 FD F0                   	JNZ	CHKSUM1
 2050/F103 : C9                         	RET
 2051/F104 :                            ;
 2052/F104 :                            ;   Shift (HL) left (C) bits.
 2053/F104 :                            ;
 2054/F104 : 0C                         SHIFTL	INR	C
 2055/F105 : 0D                         SHIFTL1	DCR	C
 2056/F106 : C8                         	RZ
 2057/F107 : 29                         	DAD	H	;shift left 1 bit.
 2058/F108 : C3 05 F1                   	JMP	SHIFTL1
 2059/F10B :                            ;
 2060/F10B :                            ;   Routine to set a bit in a 16 bit value contained in (BC).
 2061/F10B :                            ; The bit set depends on the current drive selection.
 2062/F10B :                            ;
 2063/F10B : C5                         SETBIT	PUSH	B	;save 16 bit word.
 2064/F10C : 3A 42 EF                   	LDA	ACTIVE	;get active drive.
 2065/F10F : 4F                         	MOV	C,A
 2066/F110 : 21 01 00                   	LXI	H,1
 2067/F113 : CD 04 F1                   	CALL	SHIFTL	;shift bit 0 into place.
 2068/F116 : C1                         	POP	B	;now 'or' this with the original word.
 2069/F117 : 79                         	MOV	A,C
 2070/F118 : B5                         	ORA	L
 2071/F119 : 6F                         	MOV	L,A	;low byte done, do high byte.
 2072/F11A : 78                         	MOV	A,B
 2073/F11B : B4                         	ORA	H
 2074/F11C : 67                         	MOV	H,A
 2075/F11D : C9                         	RET
 2076/F11E :                            ;
 2077/F11E :                            ;   Extract the write protect status bit for the current drive.
 2078/F11E :                            ; The result is returned in (A), bit 0.
 2079/F11E :                            ;
 2080/F11E : 2A AD F9                   GETWPRT	LHLD	WRTPRT	;get status bytes.
 2081/F121 : 3A 42 EF                   	LDA	ACTIVE	;which drive is current?
 2082/F124 : 4F                         	MOV	C,A
 2083/F125 : CD EA F0                   	CALL	SHIFTR	;shift status such that bit 0 is the
 2084/F128 : 7D                         	MOV	A,L	;one of interest for this drive.
 2085/F129 : E6 01                      	ANI	01H	;and isolate it.
 2086/F12B : C9                         	RET
 2087/F12C :                            ;
 2088/F12C :                            ;   Function to write protect the current disk.
 2089/F12C :                            ;
 2090/F12C : 21 AD F9                   WRTPRTD	LXI	H,WRTPRT;point to status word.
 2091/F12F : 4E                         	MOV	C,M	;set (BC) equal to the status.
 2092/F130 : 23                         	INX	H
 2093/F131 : 46                         	MOV	B,M
 2094/F132 : CD 0B F1                   	CALL	SETBIT	;and set this bit according to current drive.
 2095/F135 : 22 AD F9                   	SHLD	WRTPRT	;then save.
 2096/F138 : 2A C8 F9                   	LHLD	DIRSIZE	;now save directory size limit.
 2097/F13B : 23                         	INX	H	;remember the last one.
 2098/F13C : EB                         	XCHG
 2099/F13D : 2A B3 F9                   	LHLD	SCRATCH1;and store it here.
 2100/F140 : 73                         	MOV	M,E	;put low byte.
 2101/F141 : 23                         	INX	H
 2102/F142 : 72                         	MOV	M,D	;then high byte.
 2103/F143 : C9                         	RET
 2104/F144 :                            ;
 2105/F144 :                            ;   Check for a read only file.
 2106/F144 :                            ;
 2107/F144 : CD 5E F1                   CHKROFL	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
 2108/F147 : 11 09 00                   CKROF1	LXI	D,9	;look at bit 7 of the ninth byte.
 2109/F14A : 19                         	DAD	D
 2110/F14B : 7E                         	MOV	A,M
 2111/F14C : 17                         	RAL
 2112/F14D : D0                         	RNC		;return if ok.
 2113/F14E : 21 0F EC                   	LXI	H,ROFILE;else, print error message and terminate.
 2114/F151 : C3 4A EF                   	JMP	JUMPHL
 2115/F154 :                            ;
 2116/F154 :                            ;   Check the write protect status of the active disk.
 2117/F154 :                            ;
 2118/F154 : CD 1E F1                   CHKWPRT	CALL	GETWPRT
 2119/F157 : C8                         	RZ		;return if ok.
 2120/F158 : 21 0D EC                   	LXI	H,RODISK;else print message and terminate.
 2121/F15B : C3 4A EF                   	JMP	JUMPHL
 2122/F15E :                            ;
 2123/F15E :                            ;   Routine to set (HL) pointing to the proper entry in the
 2124/F15E :                            ; directory buffer.
 2125/F15E :                            ;
 2126/F15E : 2A B9 F9                   FCB2HL	LHLD	DIRBUF	;get address of buffer.
 2127/F161 : 3A E9 F9                   	LDA	FCBPOS	;relative position of file.
 2128/F164 :                            ;
 2129/F164 :                            ;   Routine to add (A) to (HL).
 2130/F164 :                            ;
 2131/F164 : 85                         ADDA2HL	ADD	L
 2132/F165 : 6F                         	MOV	L,A
 2133/F166 : D0                         	RNC
 2134/F167 : 24                         	INR	H	;take care of any carry.
 2135/F168 : C9                         	RET
 2136/F169 :                            ;
 2137/F169 :                            ;   Routine to get the 's2' byte from the fcb supplied in
 2138/F169 :                            ; the initial parameter specification.
 2139/F169 :                            ;
 2140/F169 : 2A 43 EF                   GETS2	LHLD	PARAMS	;get address of fcb.
 2141/F16C : 11 0E 00                   	LXI	D,14	;relative position of 's2'.
 2142/F16F : 19                         	DAD	D
 2143/F170 : 7E                         	MOV	A,M	;extract this byte.
 2144/F171 : C9                         	RET
 2145/F172 :                            ;
 2146/F172 :                            ;   Clear the 's2' byte in the fcb.
 2147/F172 :                            ;
 2148/F172 : CD 69 F1                   CLEARS2	CALL	GETS2	;this sets (HL) pointing to it.
 2149/F175 : 36 00                      	MVI	M,0	;now clear it.
 2150/F177 : C9                         	RET
 2151/F178 :                            ;
 2152/F178 :                            ;   Set bit 7 in the 's2' byte of the fcb.
 2153/F178 :                            ;
 2154/F178 : CD 69 F1                   SETS2B7	CALL	GETS2	;get the byte.
 2155/F17B : F6 80                      	ORI	80H	;and set bit 7.
 2156/F17D : 77                         	MOV	M,A	;then store.
 2157/F17E : C9                         	RET
 2158/F17F :                            ;
 2159/F17F :                            ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
 2160/F17F :                            ; the difference. This checks to see if there are more file
 2161/F17F :                            ; names in the directory. We are at (FILEPOS) and there are
 2162/F17F :                            ; (SCRATCH1) of them to check.
 2163/F17F :                            ;
 2164/F17F : 2A EA F9                   MOREFLS	LHLD	FILEPOS	;we are here.
 2165/F182 : EB                         	XCHG
 2166/F183 : 2A B3 F9                   	LHLD	SCRATCH1;and don't go past here.
 2167/F186 : 7B                         	MOV	A,E	;compute difference but don't keep.
 2168/F187 : 96                         	SUB	M
 2169/F188 : 23                         	INX	H
 2170/F189 : 7A                         	MOV	A,D
 2171/F18A : 9E                         	SBB	M	;set carry if no more names.
 2172/F18B : C9                         	RET
 2173/F18C :                            ;
 2174/F18C :                            ;   Call this routine to prevent (SCRATCH1) from being greater
 2175/F18C :                            ; than (FILEPOS).
 2176/F18C :                            ;
 2177/F18C : CD 7F F1                   CHKNMBR	CALL	MOREFLS	;SCRATCH1 too big?
 2178/F18F : D8                         	RC
 2179/F190 : 13                         	INX	D	;yes, reset it to (FILEPOS).
 2180/F191 : 72                         	MOV	M,D
 2181/F192 : 2B                         	DCX	H
 2182/F193 : 73                         	MOV	M,E
 2183/F194 : C9                         	RET
 2184/F195 :                            ;
 2185/F195 :                            ;   Compute (HL)=(DE)-(HL)
 2186/F195 :                            ;
 2187/F195 : 7B                         SUBHL	MOV	A,E	;compute difference.
 2188/F196 : 95                         	SUB	L
 2189/F197 : 6F                         	MOV	L,A	;store low byte.
 2190/F198 : 7A                         	MOV	A,D
 2191/F199 : 9C                         	SBB	H
 2192/F19A : 67                         	MOV	H,A	;and then high byte.
 2193/F19B : C9                         	RET
 2194/F19C :                            ;
 2195/F19C :                            ;   Set the directory checksum byte.
 2196/F19C :                            ;
 2197/F19C : 0E FF                      SETDIR	MVI	C,0FFH
 2198/F19E :                            ;
 2199/F19E :                            ;   Routine to set or compare the directory checksum byte. If
 2200/F19E :                            ; (C)=0ffh, then this will set the checksum byte. Else the byte
 2201/F19E :                            ; will be checked. If the check fails (the disk has been changed),
 2202/F19E :                            ; then this disk will be write protected.
 2203/F19E :                            ;
 2204/F19E : 2A EC F9                   CHECKDIR:LHLD	CKSUMTBL
 2205/F1A1 : EB                         	XCHG
 2206/F1A2 : 2A CC F9                   	LHLD	ALLOC1
 2207/F1A5 : CD 95 F1                   	CALL	SUBHL
 2208/F1A8 : D0                         	RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
 2209/F1A9 : C5                         	PUSH	B
 2210/F1AA : CD F7 F0                   	CALL	CHECKSUM;else compute checksum.
 2211/F1AD : 2A BD F9                   	LHLD	CHKVECT	;get address of checksum table.
 2212/F1B0 : EB                         	XCHG
 2213/F1B1 : 2A EC F9                   	LHLD	CKSUMTBL
 2214/F1B4 : 19                         	DAD	D	;set (HL) to point to byte for this drive.
 2215/F1B5 : C1                         	POP	B
 2216/F1B6 : 0C                         	INR	C	;set or check ?
 2217/F1B7 : CA C4 F1                   	JZ	CHKDIR1
 2218/F1BA : BE                         	CMP	M	;check them.
 2219/F1BB : C8                         	RZ		;return if they are the same.
 2220/F1BC : CD 7F F1                   	CALL	MOREFLS	;not the same, do we care?
 2221/F1BF : D0                         	RNC
 2222/F1C0 : CD 2C F1                   	CALL	WRTPRTD	;yes, mark this as write protected.
 2223/F1C3 : C9                         	RET
 2224/F1C4 : 77                         CHKDIR1	MOV	M,A	;just set the byte.
 2225/F1C5 : C9                         	RET
 2226/F1C6 :                            ;
 2227/F1C6 :                            ;   Do a write to the directory of the current disk.
 2228/F1C6 :                            ;
 2229/F1C6 : CD 9C F1                   DIRWRITE:CALL	SETDIR	;set checksum byte.
 2230/F1C9 : CD E0 F1                   	CALL	DIRDMA	;set directory dma address.
 2231/F1CC : 0E 01                      	MVI	C,1	;tell the bios to actually write.
 2232/F1CE : CD B8 EF                   	CALL	DOWRITE	;then do the write.
 2233/F1D1 : C3 DA F1                   	JMP	DEFDMA
 2234/F1D4 :                            ;
 2235/F1D4 :                            ;   Read from the directory.
 2236/F1D4 :                            ;
 2237/F1D4 : CD E0 F1                   DIRREAD	CALL	DIRDMA	;set the directory dma address.
 2238/F1D7 : CD B2 EF                   	CALL	DOREAD	;and read it.
 2239/F1DA :                            ;
 2240/F1DA :                            ;   Routine to set the dma address to the users choice.
 2241/F1DA :                            ;
 2242/F1DA : 21 B1 F9                   DEFDMA	LXI	H,USERDMA;reset the default dma address and return.
 2243/F1DD : C3 E3 F1                   	JMP	DIRDMA1
 2244/F1E0 :                            ;
 2245/F1E0 :                            ;   Routine to set the dma address for directory work.
 2246/F1E0 :                            ;
 2247/F1E0 : 21 B9 F9                   DIRDMA	LXI	H,DIRBUF
 2248/F1E3 :                            ;
 2249/F1E3 :                            ;   Set the dma address. On entry, (HL) points to
 2250/F1E3 :                            ; word containing the desired dma address.
 2251/F1E3 :                            ;
 2252/F1E3 : 4E                         DIRDMA1	MOV	C,M
 2253/F1E4 : 23                         	INX	H
 2254/F1E5 : 46                         	MOV	B,M	;setup (BC) and go to the bios to set it.
 2255/F1E6 : C3 24 FA                   	JMP	SETDMA
 2256/F1E9 :                            ;
 2257/F1E9 :                            ;   Move the directory buffer into user's dma space.
 2258/F1E9 :                            ;
 2259/F1E9 : 2A B9 F9                   MOVEDIR	LHLD	DIRBUF	;buffer is located here, and
 2260/F1EC : EB                         	XCHG
 2261/F1ED : 2A B1 F9                   	LHLD	USERDMA; put it here.
 2262/F1F0 : 0E 80                      	MVI	C,128	;this is its length.
 2263/F1F2 : C3 4F EF                   	JMP	DE2HL	;move it now and return.
 2264/F1F5 :                            ;
 2265/F1F5 :                            ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
 2266/F1F5 :                            ;
 2267/F1F5 : 21 EA F9                   CKFILPOS:LXI	H,FILEPOS
 2268/F1F8 : 7E                         	MOV	A,M
 2269/F1F9 : 23                         	INX	H
 2270/F1FA : BE                         	CMP	M	;are both bytes the same?
 2271/F1FB : C0                         	RNZ
 2272/F1FC : 3C                         	INR	A	;yes, but are they each 0ffh?
 2273/F1FD : C9                         	RET
 2274/F1FE :                            ;
 2275/F1FE :                            ;   Set location (FILEPOS) to 0ffffh.
 2276/F1FE :                            ;
 2277/F1FE : 21 FF FF                   STFILPOS:LXI	H,0FFFFH
 2278/F201 : 22 EA F9                   	SHLD	FILEPOS
 2279/F204 : C9                         	RET
 2280/F205 :                            ;
 2281/F205 :                            ;   Move on to the next file position within the current
 2282/F205 :                            ; directory buffer. If no more exist, set pointer to 0ffffh
 2283/F205 :                            ; and the calling routine will check for this. Enter with (C)
 2284/F205 :                            ; equal to 0ffh to cause the checksum byte to be set, else we
 2285/F205 :                            ; will check this disk and set write protect if checksums are
 2286/F205 :                            ; not the same (applies only if another directory sector must
 2287/F205 :                            ; be read).
 2288/F205 :                            ;
 2289/F205 : 2A C8 F9                   NXENTRY	LHLD	DIRSIZE	;get directory entry size limit.
 2290/F208 : EB                         	XCHG
 2291/F209 : 2A EA F9                   	LHLD	FILEPOS	;get current count.
 2292/F20C : 23                         	INX	H	;go on to the next one.
 2293/F20D : 22 EA F9                   	SHLD	FILEPOS
 2294/F210 : CD 95 F1                   	CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
 2295/F213 : D2 19 F2                   	JNC	NXENT1	;is there more room left?
 2296/F216 : C3 FE F1                   	JMP	STFILPOS;no. Set this flag and return.
 2297/F219 : 3A EA F9                   NXENT1	LDA	FILEPOS	;get file position within directory.
 2298/F21C : E6 03                      	ANI	03H	;only look within this sector (only 4 entries fit).
 2299/F21E : 06 05                      	MVI	B,5	;convert to relative position (32 bytes each).
 2300/F220 : 87                         NXENT2	ADD	A	;note that this is not efficient code.
 2301/F221 : 05                         	DCR	B	;5 'ADD A's would be better.
 2302/F222 : C2 20 F2                   	JNZ	NXENT2
 2303/F225 : 32 E9 F9                   	STA	FCBPOS	;save it as position of fcb.
 2304/F228 : B7                         	ORA	A
 2305/F229 : C0                         	RNZ		;return if we are within buffer.
 2306/F22A : C5                         	PUSH	B
 2307/F22B : CD C3 EF                   	CALL	TRKSEC	;we need the next directory sector.
 2308/F22E : CD D4 F1                   	CALL	DIRREAD
 2309/F231 : C1                         	POP	B
 2310/F232 : C3 9E F1                   	JMP	CHECKDIR
 2311/F235 :                            ;
 2312/F235 :                            ;   Routine to to get a bit from the disk space allocation
 2313/F235 :                            ; map. It is returned in (A), bit position 0. On entry to here,
 2314/F235 :                            ; set (BC) to the block number on the disk to check.
 2315/F235 :                            ; On return, (D) will contain the original bit position for
 2316/F235 :                            ; this block number and (HL) will point to the address for it.
 2317/F235 :                            ;
 2318/F235 : 79                         CKBITMAP:MOV	A,C	;determine bit number of interest.
 2319/F236 : E6 07                      	ANI	07H	;compute (D)=(E)=(C and 7)+1.
 2320/F238 : 3C                         	INR	A
 2321/F239 : 5F                         	MOV	E,A	;save particular bit number.
 2322/F23A : 57                         	MOV	D,A
 2323/F23B :                            ;
 2324/F23B :                            ;   compute (BC)=(BC)/8.
 2325/F23B :                            ;
 2326/F23B : 79                         	MOV	A,C
 2327/F23C : 0F                         	RRC		;now shift right 3 bits.
 2328/F23D : 0F                         	RRC
 2329/F23E : 0F                         	RRC
 2330/F23F : E6 1F                      	ANI	1FH	;and clear bits 7,6,5.
 2331/F241 : 4F                         	MOV	C,A
 2332/F242 : 78                         	MOV	A,B
 2333/F243 : 87                         	ADD	A	;now shift (B) into bits 7,6,5.
 2334/F244 : 87                         	ADD	A
 2335/F245 : 87                         	ADD	A
 2336/F246 : 87                         	ADD	A
 2337/F247 : 87                         	ADD	A
 2338/F248 : B1                         	ORA	C	;and add in (C).
 2339/F249 : 4F                         	MOV	C,A	;ok, (C) ha been completed.
 2340/F24A : 78                         	MOV	A,B	;is there a better way of doing this?
 2341/F24B : 0F                         	RRC
 2342/F24C : 0F                         	RRC
 2343/F24D : 0F                         	RRC
 2344/F24E : E6 1F                      	ANI	1FH
 2345/F250 : 47                         	MOV	B,A	;and now (B) is completed.
 2346/F251 :                            ;
 2347/F251 :                            ;   use this as an offset into the disk space allocation
 2348/F251 :                            ; table.
 2349/F251 :                            ;
 2350/F251 : 2A BF F9                   	LHLD	ALOCVECT
 2351/F254 : 09                         	DAD	B
 2352/F255 : 7E                         	MOV	A,M	;now get correct byte.
 2353/F256 : 07                         CKBMAP1	RLC		;get correct bit into position 0.
 2354/F257 : 1D                         	DCR	E
 2355/F258 : C2 56 F2                   	JNZ	CKBMAP1
 2356/F25B : C9                         	RET
 2357/F25C :                            ;
 2358/F25C :                            ;   Set or clear the bit map such that block number (BC) will be marked
 2359/F25C :                            ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
 2360/F25C :                            ; 1 then it will be set (don't use anyother values).
 2361/F25C :                            ;
 2362/F25C : D5                         STBITMAP:PUSH	D
 2363/F25D : CD 35 F2                   	CALL	CKBITMAP;get the byte of interest.
 2364/F260 : E6 FE                      	ANI	0FEH	;clear the affected bit.
 2365/F262 : C1                         	POP	B
 2366/F263 : B1                         	ORA	C	;and now set it acording to (C).
 2367/F264 :                            ;
 2368/F264 :                            ;  entry to restore the original bit position and then store
 2369/F264 :                            ; in table. (A) contains the value, (D) contains the bit
 2370/F264 :                            ; position (1-8), and (HL) points to the address within the
 2371/F264 :                            ; space allocation table for this byte.
 2372/F264 :                            ;
 2373/F264 : 0F                         STBMAP1	RRC		;restore original bit position.
 2374/F265 : 15                         	DCR	D
 2375/F266 : C2 64 F2                   	JNZ	STBMAP1
 2376/F269 : 77                         	MOV	M,A	;and stor byte in table.
 2377/F26A : C9                         	RET
 2378/F26B :                            ;
 2379/F26B :                            ;   Set/clear space used bits in allocation map for this file.
 2380/F26B :                            ; On entry, (C)=1 to set the map and (C)=0 to clear it.
 2381/F26B :                            ;
 2382/F26B : CD 5E F1                   SETFILE	CALL	FCB2HL	;get address of fcb
 2383/F26E : 11 10 00                   	LXI	D,16
 2384/F271 : 19                         	DAD	D	;get to block number bytes.
 2385/F272 : C5                         	PUSH	B
 2386/F273 : 0E 11                      	MVI	C,17	;check all 17 bytes (max) of table.
 2387/F275 : D1                         SETFL1	POP	D
 2388/F276 : 0D                         	DCR	C	;done all bytes yet?
 2389/F277 : C8                         	RZ
 2390/F278 : D5                         	PUSH	D
 2391/F279 : 3A DD F9                   	LDA	BIGDISK	;check disk size for 16 bit block numbers.
 2392/F27C : B7                         	ORA	A
 2393/F27D : CA 88 F2                   	JZ	SETFL2
 2394/F280 : C5                         	PUSH	B	;only 8 bit numbers. set (BC) to this one.
 2395/F281 : E5                         	PUSH	H
 2396/F282 : 4E                         	MOV	C,M	;get low byte from table, always
 2397/F283 : 06 00                      	MVI	B,0	;set high byte to zero.
 2398/F285 : C3 8E F2                   	JMP	SETFL3
 2399/F288 : 0D                         SETFL2	DCR	C	;for 16 bit block numbers, adjust counter.
 2400/F289 : C5                         	PUSH	B
 2401/F28A : 4E                         	MOV	C,M	;now get both the low and high bytes.
 2402/F28B : 23                         	INX	H
 2403/F28C : 46                         	MOV	B,M
 2404/F28D : E5                         	PUSH	H
 2405/F28E : 79                         SETFL3	MOV	A,C	;block used?
 2406/F28F : B0                         	ORA	B
 2407/F290 : CA 9D F2                   	JZ	SETFL4
 2408/F293 : 2A C6 F9                   	LHLD	DSKSIZE	;is this block number within the
 2409/F296 : 7D                         	MOV	A,L	;space on the disk?
 2410/F297 : 91                         	SUB	C
 2411/F298 : 7C                         	MOV	A,H
 2412/F299 : 98                         	SBB	B
 2413/F29A : D4 5C F2                   	CNC	STBITMAP;yes, set the proper bit.
 2414/F29D : E1                         SETFL4	POP	H	;point to next block number in fcb.
 2415/F29E : 23                         	INX	H
 2416/F29F : C1                         	POP	B
 2417/F2A0 : C3 75 F2                   	JMP	SETFL1
 2418/F2A3 :                            ;
 2419/F2A3 :                            ;   Construct the space used allocation bit map for the active
 2420/F2A3 :                            ; drive. If a file name starts with '$' and it is under the
 2421/F2A3 :                            ; current user number, then (STATUS) is set to minus 1. Otherwise
 2422/F2A3 :                            ; it is not set at all.
 2423/F2A3 :                            ;
 2424/F2A3 : 2A C6 F9                   BITMAP	LHLD	DSKSIZE	;compute size of allocation table.
 2425/F2A6 : 0E 03                      	MVI	C,3
 2426/F2A8 : CD EA F0                   	CALL	SHIFTR	;(HL)=(HL)/8.
 2427/F2AB : 23                         	INX	H	;at lease 1 byte.
 2428/F2AC : 44                         	MOV	B,H
 2429/F2AD : 4D                         	MOV	C,L	;set (BC) to the allocation table length.
 2430/F2AE :                            ;
 2431/F2AE :                            ;   Initialize the bitmap for this drive. Right now, the first
 2432/F2AE :                            ; two bytes are specified by the disk parameter block. However
 2433/F2AE :                            ; a patch could be entered here if it were necessary to setup
 2434/F2AE :                            ; this table in a special mannor. For example, the bios could
 2435/F2AE :                            ; determine locations of 'bad blocks' and set them as already
 2436/F2AE :                            ; 'used' in the map.
 2437/F2AE :                            ;
 2438/F2AE : 2A BF F9                   	LHLD	ALOCVECT;now zero out the table now.
 2439/F2B1 : 36 00                      BITMAP1	MVI	M,0
 2440/F2B3 : 23                         	INX	H
 2441/F2B4 : 0B                         	DCX	B
 2442/F2B5 : 78                         	MOV	A,B
 2443/F2B6 : B1                         	ORA	C
 2444/F2B7 : C2 B1 F2                   	JNZ	BITMAP1
 2445/F2BA : 2A CA F9                   	LHLD	ALLOC0	;get initial space used by directory.
 2446/F2BD : EB                         	XCHG
 2447/F2BE : 2A BF F9                   	LHLD	ALOCVECT;and put this into map.
 2448/F2C1 : 73                         	MOV	M,E
 2449/F2C2 : 23                         	INX	H
 2450/F2C3 : 72                         	MOV	M,D
 2451/F2C4 :                            ;
 2452/F2C4 :                            ;   End of initialization portion.
 2453/F2C4 :                            ;
 2454/F2C4 : CD A1 EF                   	CALL	HOMEDRV	;now home the drive.
 2455/F2C7 : 2A B3 F9                   	LHLD	SCRATCH1
 2456/F2CA : 36 03                      	MVI	M,3	;force next directory request to read
 2457/F2CC : 23                         	INX	H	;in a sector.
 2458/F2CD : 36 00                      	MVI	M,0
 2459/F2CF : CD FE F1                   	CALL	STFILPOS;clear initial file position also.
 2460/F2D2 : 0E FF                      BITMAP2	MVI	C,0FFH	;read next file name in directory
 2461/F2D4 : CD 05 F2                   	CALL	NXENTRY	;and set checksum byte.
 2462/F2D7 : CD F5 F1                   	CALL	CKFILPOS;is there another file?
 2463/F2DA : C8                         	RZ
 2464/F2DB : CD 5E F1                   	CALL	FCB2HL	;yes, get its address.
 2465/F2DE : 3E E5                      	MVI	A,0E5H
 2466/F2E0 : BE                         	CMP	M	;empty file entry?
 2467/F2E1 : CA D2 F2                   	JZ	BITMAP2
 2468/F2E4 : 3A 41 EF                   	LDA	USERNO	;no, correct user number?
 2469/F2E7 : BE                         	CMP	M
 2470/F2E8 : C2 F6 F2                   	JNZ	BITMAP3
 2471/F2EB : 23                         	INX	H
 2472/F2EC : 7E                         	MOV	A,M	;yes, does name start with a '$'?
 2473/F2ED : D6 24                      	SUI	'$'
 2474/F2EF : C2 F6 F2                   	JNZ	BITMAP3
 2475/F2F2 : 3D                         	DCR	A	;yes, set atatus to minus one.
 2476/F2F3 : 32 45 EF                   	STA	STATUS
 2477/F2F6 : 0E 01                      BITMAP3	MVI	C,1	;now set this file's space as used in bit map.
 2478/F2F8 : CD 6B F2                   	CALL	SETFILE
 2479/F2FB : CD 8C F1                   	CALL	CHKNMBR	;keep (SCRATCH1) in bounds.
 2480/F2FE : C3 D2 F2                   	JMP	BITMAP2
 2481/F301 :                            ;
 2482/F301 :                            ;   Set the status (STATUS) and return.
 2483/F301 :                            ;
 2484/F301 : 3A D4 F9                   STSTATUS:LDA	FNDSTAT
 2485/F304 : C3 01 EF                   	JMP	SETSTAT
 2486/F307 :                            ;
 2487/F307 :                            ;   Check extents in (A) and (C). Set the zero flag if they
 2488/F307 :                            ; are the same. The number of 16k chunks of disk space that
 2489/F307 :                            ; the directory extent covers is expressad is (EXTMASK+1).
 2490/F307 :                            ; No registers are modified.
 2491/F307 :                            ;
 2492/F307 : C5                         SAMEXT	PUSH	B
 2493/F308 : F5                         	PUSH	PSW
 2494/F309 : 3A C5 F9                   	LDA	EXTMASK	;get extent mask and use it to
 2495/F30C : 2F                         	CMA		;to compare both extent numbers.
 2496/F30D : 47                         	MOV	B,A	;save resulting mask here.
 2497/F30E : 79                         	MOV	A,C	;mask first extent and save in (C).
 2498/F30F : A0                         	ANA	B
 2499/F310 : 4F                         	MOV	C,A
 2500/F311 : F1                         	POP	PSW	;now mask second extent and compare
 2501/F312 : A0                         	ANA	B	;with the first one.
 2502/F313 : 91                         	SUB	C
 2503/F314 : E6 1F                      	ANI	1FH	;(* only check buts 0-4 *)
 2504/F316 : C1                         	POP	B	;the zero flag is set if they are the same.
 2505/F317 : C9                         	RET		;restore (BC) and return.
 2506/F318 :                            ;
 2507/F318 :                            ;   Search for the first occurence of a file name. On entry,
 2508/F318 :                            ; register (C) should contain the number of bytes of the fcb
 2509/F318 :                            ; that must match.
 2510/F318 :                            ;
 2511/F318 : 3E FF                      FINDFST	MVI	A,0FFH
 2512/F31A : 32 D4 F9                   	STA	FNDSTAT
 2513/F31D : 21 D8 F9                   	LXI	H,COUNTER;save character count.
 2514/F320 : 71                         	MOV	M,C
 2515/F321 : 2A 43 EF                   	LHLD	PARAMS	;get filename to match.
 2516/F324 : 22 D9 F9                   	SHLD	SAVEFCB	;and save.
 2517/F327 : CD FE F1                   	CALL	STFILPOS;clear initial file position (set to 0ffffh).
 2518/F32A : CD A1 EF                   	CALL	HOMEDRV	;home the drive.
 2519/F32D :                            ;
 2520/F32D :                            ;   Entry to locate the next occurence of a filename within the
 2521/F32D :                            ; directory. The disk is not expected to have been changed. If
 2522/F32D :                            ; it was, then it will be write protected.
 2523/F32D :                            ;
 2524/F32D : 0E 00                      FINDNXT	MVI	C,0	;write protect the disk if changed.
 2525/F32F : CD 05 F2                   	CALL	NXENTRY	;get next filename entry in directory.
 2526/F332 : CD F5 F1                   	CALL	CKFILPOS;is file position = 0ffffh?
 2527/F335 : CA 94 F3                   	JZ	FNDNXT6	;yes, exit now then.
 2528/F338 : 2A D9 F9                   	LHLD	SAVEFCB	;set (DE) pointing to filename to match.
 2529/F33B : EB                         	XCHG
 2530/F33C : 1A                         	LDAX	D
 2531/F33D : FE E5                      	CPI	0E5H	;empty directory entry?
 2532/F33F : CA 4A F3                   	JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
 2533/F342 : D5                         	PUSH	D
 2534/F343 : CD 7F F1                   	CALL	MOREFLS	;more files in directory?
 2535/F346 : D1                         	POP	D
 2536/F347 : D2 94 F3                   	JNC	FNDNXT6	;no more. Exit now.
 2537/F34A : CD 5E F1                   FNDNXT1	CALL	FCB2HL	;get address of this fcb in directory.
 2538/F34D : 3A D8 F9                   	LDA	COUNTER	;get number of bytes (characters) to check.
 2539/F350 : 4F                         	MOV	C,A
 2540/F351 : 06 00                      	MVI	B,0	;initialize byte position counter.
 2541/F353 : 79                         FNDNXT2	MOV	A,C	;are we done with the compare?
 2542/F354 : B7                         	ORA	A
 2543/F355 : CA 83 F3                   	JZ	FNDNXT5
 2544/F358 : 1A                         	LDAX	D	;no, check next byte.
 2545/F359 : FE 3F                      	CPI	'?'	;don't care about this character?
 2546/F35B : CA 7C F3                   	JZ	FNDNXT4
 2547/F35E : 78                         	MOV	A,B	;get bytes position in fcb.
 2548/F35F : FE 0D                      	CPI	13	;don't care about the thirteenth byte either.
 2549/F361 : CA 7C F3                   	JZ	FNDNXT4
 2550/F364 : FE 0C                      	CPI	12	;extent byte?
 2551/F366 : 1A                         	LDAX	D
 2552/F367 : CA 73 F3                   	JZ	FNDNXT3
 2553/F36A : 96                         	SUB	M	;otherwise compare characters.
 2554/F36B : E6 7F                      	ANI	7FH
 2555/F36D : C2 2D F3                   	JNZ	FINDNXT	;not the same, check next entry.
 2556/F370 : C3 7C F3                   	JMP	FNDNXT4	;so far so good, keep checking.
 2557/F373 : C5                         FNDNXT3	PUSH	B	;check the extent byte here.
 2558/F374 : 4E                         	MOV	C,M
 2559/F375 : CD 07 F3                   	CALL	SAMEXT
 2560/F378 : C1                         	POP	B
 2561/F379 : C2 2D F3                   	JNZ	FINDNXT	;not the same, look some more.
 2562/F37C :                            ;
 2563/F37C :                            ;   So far the names compare. Bump pointers to the next byte
 2564/F37C :                            ; and continue until all (C) characters have been checked.
 2565/F37C :                            ;
 2566/F37C : 13                         FNDNXT4	INX	D	;bump pointers.
 2567/F37D : 23                         	INX	H
 2568/F37E : 04                         	INR	B
 2569/F37F : 0D                         	DCR	C	;adjust character counter.
 2570/F380 : C3 53 F3                   	JMP	FNDNXT2
 2571/F383 : 3A EA F9                   FNDNXT5	LDA	FILEPOS	;return the position of this entry.
 2572/F386 : E6 03                      	ANI	03H
 2573/F388 : 32 45 EF                   	STA	STATUS
 2574/F38B : 21 D4 F9                   	LXI	H,FNDSTAT
 2575/F38E : 7E                         	MOV	A,M
 2576/F38F : 17                         	RAL
 2577/F390 : D0                         	RNC
 2578/F391 : AF                         	XRA	A
 2579/F392 : 77                         	MOV	M,A
 2580/F393 : C9                         	RET
 2581/F394 :                            ;
 2582/F394 :                            ;   Filename was not found. Set appropriate status.
 2583/F394 :                            ;
 2584/F394 : CD FE F1                   FNDNXT6	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
 2585/F397 : 3E FF                      	MVI	A,0FFH	;say not located.
 2586/F399 : C3 01 EF                   	JMP	SETSTAT
 2587/F39C :                            ;
 2588/F39C :                            ;   Erase files from the directory. Only the first byte of the
 2589/F39C :                            ; fcb will be affected. It is set to (E5).
 2590/F39C :                            ;
 2591/F39C : CD 54 F1                   ERAFILE	CALL	CHKWPRT	;is disk write protected?
 2592/F39F : 0E 0C                      	MVI	C,12	;only compare file names.
 2593/F3A1 : CD 18 F3                   	CALL	FINDFST	;get first file name.
 2594/F3A4 : CD F5 F1                   ERAFIL1	CALL	CKFILPOS;any found?
 2595/F3A7 : C8                         	RZ		;nope, we must be done.
 2596/F3A8 : CD 44 F1                   	CALL	CHKROFL	;is file read only?
 2597/F3AB : CD 5E F1                   	CALL	FCB2HL	;nope, get address of fcb and
 2598/F3AE : 36 E5                      	MVI	M,0E5H	;set first byte to 'empty'.
 2599/F3B0 : 0E 00                      	MVI	C,0	;clear the space from the bit map.
 2600/F3B2 : CD 6B F2                   	CALL	SETFILE
 2601/F3B5 : CD C6 F1                   	CALL	DIRWRITE;now write the directory sector back out.
 2602/F3B8 : CD 2D F3                   	CALL	FINDNXT	;find the next file name.
 2603/F3BB : C3 A4 F3                   	JMP	ERAFIL1	;and repeat process.
 2604/F3BE :                            ;
 2605/F3BE :                            ;   Look through the space allocation map (bit map) for the
 2606/F3BE :                            ; next available block. Start searching at block number (BC-1).
 2607/F3BE :                            ; The search procedure is to look for an empty block that is
 2608/F3BE :                            ; before the starting block. If not empty, look at a later
 2609/F3BE :                            ; block number. In this way, we return the closest empty block
 2610/F3BE :                            ; on either side of the 'target' block number. This will speed
 2611/F3BE :                            ; access on random devices. For serial devices, this should be
 2612/F3BE :                            ; changed to look in the forward direction first and then start
 2613/F3BE :                            ; at the front and search some more.
 2614/F3BE :                            ;
 2615/F3BE :                            ;   On return, (DE)= block number that is empty and (HL) =0
 2616/F3BE :                            ; if no empry block was found.
 2617/F3BE :                            ;
 2618/F3BE : 50                         FNDSPACE:MOV	D,B	;set (DE) as the block that is checked.
 2619/F3BF : 59                         	MOV	E,C
 2620/F3C0 :                            ;
 2621/F3C0 :                            ;   Look before target block. Registers (BC) are used as the lower
 2622/F3C0 :                            ; pointer and (DE) as the upper pointer.
 2623/F3C0 :                            ;
 2624/F3C0 : 79                         FNDSPA1	MOV	A,C	;is block 0 specified?
 2625/F3C1 : B0                         	ORA	B
 2626/F3C2 : CA D1 F3                   	JZ	FNDSPA2
 2627/F3C5 : 0B                         	DCX	B	;nope, check previous block.
 2628/F3C6 : D5                         	PUSH	D
 2629/F3C7 : C5                         	PUSH	B
 2630/F3C8 : CD 35 F2                   	CALL	CKBITMAP
 2631/F3CB : 1F                         	RAR		;is this block empty?
 2632/F3CC : D2 EC F3                   	JNC	FNDSPA3	;yes. use this.
 2633/F3CF :                            ;
 2634/F3CF :                            ;   Note that the above logic gets the first block that it finds
 2635/F3CF :                            ; that is empty. Thus a file could be written 'backward' making
 2636/F3CF :                            ; it very slow to access. This could be changed to look for the
 2637/F3CF :                            ; first empty block and then continue until the start of this
 2638/F3CF :                            ; empty space is located and then used that starting block.
 2639/F3CF :                            ; This should help speed up access to some files especially on
 2640/F3CF :                            ; a well used disk with lots of fairly small 'holes'.
 2641/F3CF :                            ;
 2642/F3CF : C1                         	POP	B	;nope, check some more.
 2643/F3D0 : D1                         	POP	D
 2644/F3D1 :                            ;
 2645/F3D1 :                            ;   Now look after target block.
 2646/F3D1 :                            ;
 2647/F3D1 : 2A C6 F9                   FNDSPA2	LHLD	DSKSIZE	;is block (DE) within disk limits?
 2648/F3D4 : 7B                         	MOV	A,E
 2649/F3D5 : 95                         	SUB	L
 2650/F3D6 : 7A                         	MOV	A,D
 2651/F3D7 : 9C                         	SBB	H
 2652/F3D8 : D2 F4 F3                   	JNC	FNDSPA4
 2653/F3DB : 13                         	INX	D	;yes, move on to next one.
 2654/F3DC : C5                         	PUSH	B
 2655/F3DD : D5                         	PUSH	D
 2656/F3DE : 42                         	MOV	B,D
 2657/F3DF : 4B                         	MOV	C,E
 2658/F3E0 : CD 35 F2                   	CALL	CKBITMAP;check it.
 2659/F3E3 : 1F                         	RAR		;empty?
 2660/F3E4 : D2 EC F3                   	JNC	FNDSPA3
 2661/F3E7 : D1                         	POP	D	;nope, continue searching.
 2662/F3E8 : C1                         	POP	B
 2663/F3E9 : C3 C0 F3                   	JMP	FNDSPA1
 2664/F3EC :                            ;
 2665/F3EC :                            ;   Empty block found. Set it as used and return with (HL)
 2666/F3EC :                            ; pointing to it (true?).
 2667/F3EC :                            ;
 2668/F3EC : 17                         FNDSPA3	RAL		;reset byte.
 2669/F3ED : 3C                         	INR	A	;and set bit 0.
 2670/F3EE : CD 64 F2                   	CALL	STBMAP1	;update bit map.
 2671/F3F1 : E1                         	POP	H	;set return registers.
 2672/F3F2 : D1                         	POP	D
 2673/F3F3 : C9                         	RET
 2674/F3F4 :                            ;
 2675/F3F4 :                            ;   Free block was not found. If (BC) is not zero, then we have
 2676/F3F4 :                            ; not checked all of the disk space.
 2677/F3F4 :                            ;
 2678/F3F4 : 79                         FNDSPA4	MOV	A,C
 2679/F3F5 : B0                         	ORA	B
 2680/F3F6 : C2 C0 F3                   	JNZ	FNDSPA1
 2681/F3F9 : 21 00 00                   	LXI	H,0	;set 'not found' status.
 2682/F3FC : C9                         	RET
 2683/F3FD :                            ;
 2684/F3FD :                            ;   Move a complete fcb entry into the directory and write it.
 2685/F3FD :                            ;
 2686/F3FD : 0E 00                      FCBSET	MVI	C,0
 2687/F3FF : 1E 20                      	MVI	E,32	;length of each entry.
 2688/F401 :                            ;
 2689/F401 :                            ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
 2690/F401 :                            ; fcb in directory starting at relative byte (C). This updated
 2691/F401 :                            ; directory buffer is then written to the disk.
 2692/F401 :                            ;
 2693/F401 : D5                         UPDATE	PUSH	D
 2694/F402 : 06 00                      	MVI	B,0	;set (BC) to relative byte position.
 2695/F404 : 2A 43 EF                   	LHLD	PARAMS	;get address of fcb.
 2696/F407 : 09                         	DAD	B	;compute starting byte.
 2697/F408 : EB                         	XCHG
 2698/F409 : CD 5E F1                   	CALL	FCB2HL	;get address of fcb to update in directory.
 2699/F40C : C1                         	POP	B	;set (C) to number of bytes to change.
 2700/F40D : CD 4F EF                   	CALL	DE2HL
 2701/F410 : CD C3 EF                   UPDATE1	CALL	TRKSEC	;determine the track and sector affected.
 2702/F413 : C3 C6 F1                   	JMP	DIRWRITE	;then write this sector out.
 2703/F416 :                            ;
 2704/F416 :                            ;   Routine to change the name of all files on the disk with a
 2705/F416 :                            ; specified name. The fcb contains the current name as the
 2706/F416 :                            ; first 12 characters and the new name 16 bytes into the fcb.
 2707/F416 :                            ;
 2708/F416 : CD 54 F1                   CHGNAMES:CALL	CHKWPRT	;check for a write protected disk.
 2709/F419 : 0E 0C                      	MVI	C,12	;match first 12 bytes of fcb only.
 2710/F41B : CD 18 F3                   	CALL	FINDFST	;get first name.
 2711/F41E : 2A 43 EF                   	LHLD	PARAMS	;get address of fcb.
 2712/F421 : 7E                         	MOV	A,M	;get user number.
 2713/F422 : 11 10 00                   	LXI	D,16	;move over to desired name.
 2714/F425 : 19                         	DAD	D
 2715/F426 : 77                         	MOV	M,A	;keep same user number.
 2716/F427 : CD F5 F1                   CHGNAM1	CALL	CKFILPOS;any matching file found?
 2717/F42A : C8                         	RZ		;no, we must be done.
 2718/F42B : CD 44 F1                   	CALL	CHKROFL	;check for read only file.
 2719/F42E : 0E 10                      	MVI	C,16	;start 16 bytes into fcb.
 2720/F430 : 1E 0C                      	MVI	E,12	;and update the first 12 bytes of directory.
 2721/F432 : CD 01 F4                   	CALL	UPDATE
 2722/F435 : CD 2D F3                   	CALL	FINDNXT	;get te next file name.
 2723/F438 : C3 27 F4                   	JMP	CHGNAM1	;and continue.
 2724/F43B :                            ;
 2725/F43B :                            ;   Update a files attributes. The procedure is to search for
 2726/F43B :                            ; every file with the same name as shown in fcb (ignoring bit 7)
 2727/F43B :                            ; and then to update it (which includes bit 7). No other changes
 2728/F43B :                            ; are made.
 2729/F43B :                            ;
 2730/F43B : 0E 0C                      SAVEATTR:MVI	C,12	;match first 12 bytes.
 2731/F43D : CD 18 F3                   	CALL	FINDFST	;look for first filename.
 2732/F440 : CD F5 F1                   SAVATR1	CALL	CKFILPOS;was one found?
 2733/F443 : C8                         	RZ		;nope, we must be done.
 2734/F444 : 0E 00                      	MVI	C,0	;yes, update the first 12 bytes now.
 2735/F446 : 1E 0C                      	MVI	E,12
 2736/F448 : CD 01 F4                   	CALL	UPDATE	;update filename and write directory.
 2737/F44B : CD 2D F3                   	CALL	FINDNXT	;and get the next file.
 2738/F44E : C3 40 F4                   	JMP	SAVATR1	;then continue until done.
 2739/F451 :                            ;
 2740/F451 :                            ;  Open a file (name specified in fcb).
 2741/F451 :                            ;
 2742/F451 : 0E 0F                      OPENIT	MVI	C,15	;compare the first 15 bytes.
 2743/F453 : CD 18 F3                   	CALL	FINDFST	;get the first one in directory.
 2744/F456 : CD F5 F1                   	CALL	CKFILPOS;any at all?
 2745/F459 : C8                         	RZ
 2746/F45A : CD A6 F0                   OPENIT1	CALL	SETEXT	;point to extent byte within users fcb.
 2747/F45D : 7E                         	MOV	A,M	;and get it.
 2748/F45E : F5                         	PUSH	PSW	;save it and address.
 2749/F45F : E5                         	PUSH	H
 2750/F460 : CD 5E F1                   	CALL	FCB2HL	;point to fcb in directory.
 2751/F463 : EB                         	XCHG
 2752/F464 : 2A 43 EF                   	LHLD	PARAMS	;this is the users copy.
 2753/F467 : 0E 20                      	MVI	C,32	;move it into users space.
 2754/F469 : D5                         	PUSH	D
 2755/F46A : CD 4F EF                   	CALL	DE2HL
 2756/F46D : CD 78 F1                   	CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
 2757/F470 : D1                         	POP	D	;now get the extent byte from this fcb.
 2758/F471 : 21 0C 00                   	LXI	H,12
 2759/F474 : 19                         	DAD	D
 2760/F475 : 4E                         	MOV	C,M	;into (C).
 2761/F476 : 21 0F 00                   	LXI	H,15	;now get the record count byte into (B).
 2762/F479 : 19                         	DAD	D
 2763/F47A : 46                         	MOV	B,M
 2764/F47B : E1                         	POP	H	;keep the same extent as the user had originally.
 2765/F47C : F1                         	POP	PSW
 2766/F47D : 77                         	MOV	M,A
 2767/F47E : 79                         	MOV	A,C	;is it the same as in the directory fcb?
 2768/F47F : BE                         	CMP	M
 2769/F480 : 78                         	MOV	A,B	;if yes, then use the same record count.
 2770/F481 : CA 8B F4                   	JZ	OPENIT2
 2771/F484 : 3E 00                      	MVI	A,0	;if the user specified an extent greater than
 2772/F486 : DA 8B F4                   	JC	OPENIT2	;the one in the directory, then set record count to 0.
 2773/F489 : 3E 80                      	MVI	A,128	;otherwise set to maximum.
 2774/F48B : 2A 43 EF                   OPENIT2	LHLD	PARAMS	;set record count in users fcb to (A).
 2775/F48E : 11 0F 00                   	LXI	D,15
 2776/F491 : 19                         	DAD	D	;compute relative position.
 2777/F492 : 77                         	MOV	M,A	;and set the record count.
 2778/F493 : C9                         	RET
 2779/F494 :                            ;
 2780/F494 :                            ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
 2781/F494 :                            ; point to a zero value (16 bit).
 2782/F494 :                            ;   Return with zero flag set it (DE) was moved. Registers (DE)
 2783/F494 :                            ; and (HL) are not changed. However (A) is.
 2784/F494 :                            ;
 2785/F494 : 7E                         MOVEWORD:MOV	A,M	;check for a zero word.
 2786/F495 : 23                         	INX	H
 2787/F496 : B6                         	ORA	M	;both bytes zero?
 2788/F497 : 2B                         	DCX	H
 2789/F498 : C0                         	RNZ		;nope, just return.
 2790/F499 : 1A                         	LDAX	D	;yes, move two bytes from (DE) into
 2791/F49A : 77                         	MOV	M,A	;this zero space.
 2792/F49B : 13                         	INX	D
 2793/F49C : 23                         	INX	H
 2794/F49D : 1A                         	LDAX	D
 2795/F49E : 77                         	MOV	M,A
 2796/F49F : 1B                         	DCX	D	;don't disturb these registers.
 2797/F4A0 : 2B                         	DCX	H
 2798/F4A1 : C9                         	RET
 2799/F4A2 :                            ;
 2800/F4A2 :                            ;   Get here to close a file specified by (fcb).
 2801/F4A2 :                            ;
 2802/F4A2 : AF                         CLOSEIT	XRA	A	;clear status and file position bytes.
 2803/F4A3 : 32 45 EF                   	STA	STATUS
 2804/F4A6 : 32 EA F9                   	STA	FILEPOS
 2805/F4A9 : 32 EB F9                   	STA	FILEPOS+1
 2806/F4AC : CD 1E F1                   	CALL	GETWPRT	;get write protect bit for this drive.
 2807/F4AF : C0                         	RNZ		;just return if it is set.
 2808/F4B0 : CD 69 F1                   	CALL	GETS2	;else get the 's2' byte.
 2809/F4B3 : E6 80                      	ANI	80H	;and look at bit 7 (file unmodified?).
 2810/F4B5 : C0                         	RNZ		;just return if set.
 2811/F4B6 : 0E 0F                      	MVI	C,15	;else look up this file in directory.
 2812/F4B8 : CD 18 F3                   	CALL	FINDFST
 2813/F4BB : CD F5 F1                   	CALL	CKFILPOS;was it found?
 2814/F4BE : C8                         	RZ		;just return if not.
 2815/F4BF : 01 10 00                   	LXI	B,16	;set (HL) pointing to records used section.
 2816/F4C2 : CD 5E F1                   	CALL	FCB2HL
 2817/F4C5 : 09                         	DAD	B
 2818/F4C6 : EB                         	XCHG
 2819/F4C7 : 2A 43 EF                   	LHLD	PARAMS	;do the same for users specified fcb.
 2820/F4CA : 09                         	DAD	B
 2821/F4CB : 0E 10                      	MVI	C,16	;this many bytes are present in this extent.
 2822/F4CD : 3A DD F9                   CLOSEIT1:LDA	BIGDISK	;8 or 16 bit record numbers?
 2823/F4D0 : B7                         	ORA	A
 2824/F4D1 : CA E8 F4                   	JZ	CLOSEIT4
 2825/F4D4 : 7E                         	MOV	A,M	;just 8 bit. Get one from users fcb.
 2826/F4D5 : B7                         	ORA	A
 2827/F4D6 : 1A                         	LDAX	D	;now get one from directory fcb.
 2828/F4D7 : C2 DB F4                   	JNZ	CLOSEIT2
 2829/F4DA : 77                         	MOV	M,A	;users byte was zero. Update from directory.
 2830/F4DB : B7                         CLOSEIT2:ORA	A
 2831/F4DC : C2 E1 F4                   	JNZ	CLOSEIT3
 2832/F4DF : 7E                         	MOV	A,M	;directories byte was zero, update from users fcb.
 2833/F4E0 : 12                         	STAX	D
 2834/F4E1 : BE                         CLOSEIT3:CMP	M	;if neither one of these bytes were zero,
 2835/F4E2 : C2 1F F5                   	JNZ	CLOSEIT7	;then close error if they are not the same.
 2836/F4E5 : C3 FD F4                   	JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
 2837/F4E8 : CD 94 F4                   CLOSEIT4:CALL	MOVEWORD;update users fcb if it is zero.
 2838/F4EB : EB                         	XCHG
 2839/F4EC : CD 94 F4                   	CALL	MOVEWORD;update directories fcb if it is zero.
 2840/F4EF : EB                         	XCHG
 2841/F4F0 : 1A                         	LDAX	D	;if these two values are no different,
 2842/F4F1 : BE                         	CMP	M	;then a close error occured.
 2843/F4F2 : C2 1F F5                   	JNZ	CLOSEIT7
 2844/F4F5 : 13                         	INX	D	;check second byte.
 2845/F4F6 : 23                         	INX	H
 2846/F4F7 : 1A                         	LDAX	D
 2847/F4F8 : BE                         	CMP	M
 2848/F4F9 : C2 1F F5                   	JNZ	CLOSEIT7
 2849/F4FC : 0D                         	DCR	C	;remember 16 bit values.
 2850/F4FD : 13                         CLOSEIT5:INX	D	;bump to next item in table.
 2851/F4FE : 23                         	INX	H
 2852/F4FF : 0D                         	DCR	C	;there are 16 entries only.
 2853/F500 : C2 CD F4                   	JNZ	CLOSEIT1;continue if more to do.
 2854/F503 : 01 EC FF                   	LXI	B,0FFECH;backup 20 places (extent byte).
 2855/F506 : 09                         	DAD	B
 2856/F507 : EB                         	XCHG
 2857/F508 : 09                         	DAD	B
 2858/F509 : 1A                         	LDAX	D
 2859/F50A : BE                         	CMP	M	;directory's extent already greater than the
 2860/F50B : DA 17 F5                   	JC	CLOSEIT6	;users extent?
 2861/F50E : 77                         	MOV	M,A	;no, update directory extent.
 2862/F50F : 01 03 00                   	LXI	B,3	;and update the record count byte in
 2863/F512 : 09                         	DAD	B	;directories fcb.
 2864/F513 : EB                         	XCHG
 2865/F514 : 09                         	DAD	B
 2866/F515 : 7E                         	MOV	A,M	;get from user.
 2867/F516 : 12                         	STAX	D	;and put in directory.
 2868/F517 : 3E FF                      CLOSEIT6:MVI	A,0FFH	;set 'was open and is now closed' byte.
 2869/F519 : 32 D2 F9                   	STA	CLOSEFLG
 2870/F51C : C3 10 F4                   	JMP	UPDATE1	;update the directory now.
 2871/F51F : 21 45 EF                   CLOSEIT7:LXI	H,STATUS;set return status and then return.
 2872/F522 : 35                         	DCR	M
 2873/F523 : C9                         	RET
 2874/F524 :                            ;
 2875/F524 :                            ;   Routine to get the next empty space in the directory. It
 2876/F524 :                            ; will then be cleared for use.
 2877/F524 :                            ;
 2878/F524 : CD 54 F1                   GETEMPTY:CALL	CHKWPRT	;make sure disk is not write protected.
 2879/F527 : 2A 43 EF                   	LHLD	PARAMS	;save current parameters (fcb).
 2880/F52A : E5                         	PUSH	H
 2881/F52B : 21 AC F9                   	LXI	H,EMPTYFCB;use special one for empty space.
 2882/F52E : 22 43 EF                   	SHLD	PARAMS
 2883/F531 : 0E 01                      	MVI	C,1	;search for first empty spot in directory.
 2884/F533 : CD 18 F3                   	CALL	FINDFST	;(* only check first byte *)
 2885/F536 : CD F5 F1                   	CALL	CKFILPOS;none?
 2886/F539 : E1                         	POP	H
 2887/F53A : 22 43 EF                   	SHLD	PARAMS	;restore original fcb address.
 2888/F53D : C8                         	RZ		;return if no more space.
 2889/F53E : EB                         	XCHG
 2890/F53F : 21 0F 00                   	LXI	H,15	;point to number of records for this file.
 2891/F542 : 19                         	DAD	D
 2892/F543 : 0E 11                      	MVI	C,17	;and clear all of this space.
 2893/F545 : AF                         	XRA	A
 2894/F546 : 77                         GETMT1	MOV	M,A
 2895/F547 : 23                         	INX	H
 2896/F548 : 0D                         	DCR	C
 2897/F549 : C2 46 F5                   	JNZ	GETMT1
 2898/F54C : 21 0D 00                   	LXI	H,13	;clear the 's1' byte also.
 2899/F54F : 19                         	DAD	D
 2900/F550 : 77                         	MOV	M,A
 2901/F551 : CD 8C F1                   	CALL	CHKNMBR	;keep (SCRATCH1) within bounds.
 2902/F554 : CD FD F3                   	CALL	FCBSET	;write out this fcb entry to directory.
 2903/F557 : C3 78 F1                   	JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
 2904/F55A :                            ;
 2905/F55A :                            ;   Routine to close the current extent and open the next one
 2906/F55A :                            ; for reading.
 2907/F55A :                            ;
 2908/F55A : AF                         GETNEXT	XRA	A
 2909/F55B : 32 D2 F9                   	STA	CLOSEFLG;clear close flag.
 2910/F55E : CD A2 F4                   	CALL	CLOSEIT	;close this extent.
 2911/F561 : CD F5 F1                   	CALL	CKFILPOS
 2912/F564 : C8                         	RZ		;not there???
 2913/F565 : 2A 43 EF                   	LHLD	PARAMS	;get extent byte.
 2914/F568 : 01 0C 00                   	LXI	B,12
 2915/F56B : 09                         	DAD	B
 2916/F56C : 7E                         	MOV	A,M	;and increment it.
 2917/F56D : 3C                         	INR	A
 2918/F56E : E6 1F                      	ANI	1FH	;keep within range 0-31.
 2919/F570 : 77                         	MOV	M,A
 2920/F571 : CA 83 F5                   	JZ	GTNEXT1	;overflow?
 2921/F574 : 47                         	MOV	B,A	;mask extent byte.
 2922/F575 : 3A C5 F9                   	LDA	EXTMASK
 2923/F578 : A0                         	ANA	B
 2924/F579 : 21 D2 F9                   	LXI	H,CLOSEFLG;check close flag (0ffh is ok).
 2925/F57C : A6                         	ANA	M
 2926/F57D : CA 8E F5                   	JZ	GTNEXT2	;if zero, we must read in next extent.
 2927/F580 : C3 AC F5                   	JMP	GTNEXT3	;else, it is already in memory.
 2928/F583 : 01 02 00                   GTNEXT1	LXI	B,2	;Point to the 's2' byte.
 2929/F586 : 09                         	DAD	B
 2930/F587 : 34                         	INR	M	;and bump it.
 2931/F588 : 7E                         	MOV	A,M	;too many extents?
 2932/F589 : E6 0F                      	ANI	0FH
 2933/F58B : CA B6 F5                   	JZ	GTNEXT5	;yes, set error code.
 2934/F58E :                            ;
 2935/F58E :                            ;   Get here to open the next extent.
 2936/F58E :                            ;
 2937/F58E : 0E 0F                      GTNEXT2	MVI	C,15	;set to check first 15 bytes of fcb.
 2938/F590 : CD 18 F3                   	CALL	FINDFST	;find the first one.
 2939/F593 : CD F5 F1                   	CALL	CKFILPOS;none available?
 2940/F596 : C2 AC F5                   	JNZ	GTNEXT3
 2941/F599 : 3A D3 F9                   	LDA	RDWRTFLG;no extent present. Can we open an empty one?
 2942/F59C : 3C                         	INR	A	;0ffh means reading (so not possible).
 2943/F59D : CA B6 F5                   	JZ	GTNEXT5	;or an error.
 2944/F5A0 : CD 24 F5                   	CALL	GETEMPTY;we are writing, get an empty entry.
 2945/F5A3 : CD F5 F1                   	CALL	CKFILPOS;none?
 2946/F5A6 : CA B6 F5                   	JZ	GTNEXT5	;error if true.
 2947/F5A9 : C3 AF F5                   	JMP	GTNEXT4	;else we are almost done.
 2948/F5AC : CD 5A F4                   GTNEXT3	CALL	OPENIT1	;open this extent.
 2949/F5AF : CD BB F0                   GTNEXT4	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
 2950/F5B2 : AF                         	XRA	A	;clear status and return.
 2951/F5B3 : C3 01 EF                   	JMP	SETSTAT
 2952/F5B6 :                            ;
 2953/F5B6 :                            ;   Error in extending the file. Too many extents were needed
 2954/F5B6 :                            ; or not enough space on the disk.
 2955/F5B6 :                            ;
 2956/F5B6 : CD 05 EF                   GTNEXT5	CALL	IOERR1	;set error code, clear bit 7 of 's2'
 2957/F5B9 : C3 78 F1                   	JMP	SETS2B7	;so this is not written on a close.
 2958/F5BC :                            ;
 2959/F5BC :                            ;   Read a sequential file.
 2960/F5BC :                            ;
 2961/F5BC : 3E 01                      RDSEQ	MVI	A,1	;set sequential access mode.
 2962/F5BE : 32 D5 F9                   	STA	MODE
 2963/F5C1 : 3E FF                      RDSEQ1	MVI	A,0FFH	;don't allow reading unwritten space.
 2964/F5C3 : 32 D3 F9                   	STA	RDWRTFLG
 2965/F5C6 : CD BB F0                   	CALL	STRDATA	;put rec# and ext# into fcb.
 2966/F5C9 : 3A E3 F9                   	LDA	SAVNREC	;get next record to read.
 2967/F5CC : 21 E1 F9                   	LXI	H,SAVNXT;get number of records in extent.
 2968/F5CF : BE                         	CMP	M	;within this extent?
 2969/F5D0 : DA E6 F5                   	JC	RDSEQ2
 2970/F5D3 : FE 80                      	CPI	128	;no. Is this extent fully used?
 2971/F5D5 : C2 FB F5                   	JNZ	RDSEQ3	;no. End-of-file.
 2972/F5D8 : CD 5A F5                   	CALL	GETNEXT	;yes, open the next one.
 2973/F5DB : AF                         	XRA	A	;reset next record to read.
 2974/F5DC : 32 E3 F9                   	STA	SAVNREC
 2975/F5DF : 3A 45 EF                   	LDA	STATUS	;check on open, successful?
 2976/F5E2 : B7                         	ORA	A
 2977/F5E3 : C2 FB F5                   	JNZ	RDSEQ3	;no, error.
 2978/F5E6 : CD 77 F0                   RDSEQ2	CALL	COMBLK	;ok. compute block number to read.
 2979/F5E9 : CD 84 F0                   	CALL	CHKBLK	;check it. Within bounds?
 2980/F5EC : CA FB F5                   	JZ	RDSEQ3	;no, error.
 2981/F5EF : CD 8A F0                   	CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
 2982/F5F2 : CD D1 EF                   	CALL	TRKSEC1	;set the track and sector for this block #.
 2983/F5F5 : CD B2 EF                   	CALL	DOREAD	;and read it.
 2984/F5F8 : C3 D2 F0                   	JMP	SETNREC	;and set the next record to be accessed.
 2985/F5FB :                            ;
 2986/F5FB :                            ;   Read error occured. Set status and return.
 2987/F5FB :                            ;
 2988/F5FB : C3 05 EF                   RDSEQ3	JMP	IOERR1
 2989/F5FE :                            ;
 2990/F5FE :                            ;   Write the next sequential record.
 2991/F5FE :                            ;
 2992/F5FE : 3E 01                      WTSEQ	MVI	A,1	;set sequential access mode.
 2993/F600 : 32 D5 F9                   	STA	MODE
 2994/F603 : 3E 00                      WTSEQ1	MVI	A,0	;allow an addition empty extent to be opened.
 2995/F605 : 32 D3 F9                   	STA	RDWRTFLG
 2996/F608 : CD 54 F1                   	CALL	CHKWPRT	;check write protect status.
 2997/F60B : 2A 43 EF                   	LHLD	PARAMS
 2998/F60E : CD 47 F1                   	CALL	CKROF1	;check for read only file, (HL) already set to fcb.
 2999/F611 : CD BB F0                   	CALL	STRDATA	;put updated data into fcb.
 3000/F614 : 3A E3 F9                   	LDA	SAVNREC	;get record number to write.
 3001/F617 : FE 80                      	CPI	128	;within range?
 3002/F619 : D2 05 EF                   	JNC	IOERR1	;no, error(?).
 3003/F61C : CD 77 F0                   	CALL	COMBLK	;compute block number.
 3004/F61F : CD 84 F0                   	CALL	CHKBLK	;check number.
 3005/F622 : 0E 00                      	MVI	C,0	;is there one to write to?
 3006/F624 : C2 6E F6                   	JNZ	WTSEQ6	;yes, go do it.
 3007/F627 : CD 3E F0                   	CALL	GETBLOCK;get next block number within fcb to use.
 3008/F62A : 32 D7 F9                   	STA	RELBLOCK;and save.
 3009/F62D : 01 00 00                   	LXI	B,0	;start looking for space from the start
 3010/F630 : B7                         	ORA	A	;if none allocated as yet.
 3011/F631 : CA 3B F6                   	JZ	WTSEQ2
 3012/F634 : 4F                         	MOV	C,A	;extract previous block number from fcb
 3013/F635 : 0B                         	DCX	B	;so we can be closest to it.
 3014/F636 : CD 5E F0                   	CALL	EXTBLK
 3015/F639 : 44                         	MOV	B,H
 3016/F63A : 4D                         	MOV	C,L
 3017/F63B : CD BE F3                   WTSEQ2	CALL	FNDSPACE;find the next empty block nearest number (BC).
 3018/F63E : 7D                         	MOV	A,L	;check for a zero number.
 3019/F63F : B4                         	ORA	H
 3020/F640 : C2 48 F6                   	JNZ	WTSEQ3
 3021/F643 : 3E 02                      	MVI	A,2	;no more space?
 3022/F645 : C3 01 EF                   	JMP	SETSTAT
 3023/F648 : 22 E5 F9                   WTSEQ3	SHLD	BLKNMBR	;save block number to access.
 3024/F64B : EB                         	XCHG		;put block number into (DE).
 3025/F64C : 2A 43 EF                   	LHLD	PARAMS	;now we must update the fcb for this
 3026/F64F : 01 10 00                   	LXI	B,16	;newly allocated block.
 3027/F652 : 09                         	DAD	B
 3028/F653 : 3A DD F9                   	LDA	BIGDISK	;8 or 16 bit block numbers?
 3029/F656 : B7                         	ORA	A
 3030/F657 : 3A D7 F9                   	LDA	RELBLOCK	;(* update this entry *)
 3031/F65A : CA 64 F6                   	JZ	WTSEQ4	;zero means 16 bit ones.
 3032/F65D : CD 64 F1                   	CALL	ADDA2HL	;(HL)=(HL)+(A)
 3033/F660 : 73                         	MOV	M,E	;store new block number.
 3034/F661 : C3 6C F6                   	JMP	WTSEQ5
 3035/F664 : 4F                         WTSEQ4	MOV	C,A	;compute spot in this 16 bit table.
 3036/F665 : 06 00                      	MVI	B,0
 3037/F667 : 09                         	DAD	B
 3038/F668 : 09                         	DAD	B
 3039/F669 : 73                         	MOV	M,E	;stuff block number (DE) there.
 3040/F66A : 23                         	INX	H
 3041/F66B : 72                         	MOV	M,D
 3042/F66C : 0E 02                      WTSEQ5	MVI	C,2	;set (C) to indicate writing to un-used disk space.
 3043/F66E : 3A 45 EF                   WTSEQ6	LDA	STATUS	;are we ok so far?
 3044/F671 : B7                         	ORA	A
 3045/F672 : C0                         	RNZ
 3046/F673 : C5                         	PUSH	B	;yes, save write flag for bios (register C).
 3047/F674 : CD 8A F0                   	CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
 3048/F677 : 3A D5 F9                   	LDA	MODE	;get access mode flag (1=sequential,
 3049/F67A : 3D                         	DCR	A	;0=random, 2=special?).
 3050/F67B : 3D                         	DCR	A
 3051/F67C : C2 BB F6                   	JNZ	WTSEQ9
 3052/F67F :                            ;
 3053/F67F :                            ;   Special random i/o from function #40. Maybe for M/PM, but the
 3054/F67F :                            ; current block, if it has not been written to, will be zeroed
 3055/F67F :                            ; out and then written (reason?).
 3056/F67F :                            ;
 3057/F67F : C1                         	POP	B
 3058/F680 : C5                         	PUSH	B
 3059/F681 : 79                         	MOV	A,C	;get write status flag (2=writing unused space).
 3060/F682 : 3D                         	DCR	A
 3061/F683 : 3D                         	DCR	A
 3062/F684 : C2 BB F6                   	JNZ	WTSEQ9
 3063/F687 : E5                         	PUSH	H
 3064/F688 : 2A B9 F9                   	LHLD	DIRBUF	;zero out the directory buffer.
 3065/F68B : 57                         	MOV	D,A	;note that (A) is zero here.
 3066/F68C : 77                         WTSEQ7	MOV	M,A
 3067/F68D : 23                         	INX	H
 3068/F68E : 14                         	INR	D	;do 128 bytes.
 3069/F68F : F2 8C F6                   	JP	WTSEQ7
 3070/F692 : CD E0 F1                   	CALL	DIRDMA	;tell the bios the dma address for directory access.
 3071/F695 : 2A E7 F9                   	LHLD	LOGSECT	;get sector that starts current block.
 3072/F698 : 0E 02                      	MVI	C,2	;set 'writing to unused space' flag.
 3073/F69A : 22 E5 F9                   WTSEQ8	SHLD	BLKNMBR	;save sector to write.
 3074/F69D : C5                         	PUSH	B
 3075/F69E : CD D1 EF                   	CALL	TRKSEC1	;determine its track and sector numbers.
 3076/F6A1 : C1                         	POP	B
 3077/F6A2 : CD B8 EF                   	CALL	DOWRITE	;now write out 128 bytes of zeros.
 3078/F6A5 : 2A E5 F9                   	LHLD	BLKNMBR	;get sector number.
 3079/F6A8 : 0E 00                      	MVI	C,0	;set normal write flag.
 3080/F6AA : 3A C4 F9                   	LDA	BLKMASK	;determine if we have written the entire
 3081/F6AD : 47                         	MOV	B,A	;physical block.
 3082/F6AE : A5                         	ANA	L
 3083/F6AF : B8                         	CMP	B
 3084/F6B0 : 23                         	INX	H	;prepare for the next one.
 3085/F6B1 : C2 9A F6                   	JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
 3086/F6B4 : E1                         	POP	H	;reset next sector number.
 3087/F6B5 : 22 E5 F9                   	SHLD	BLKNMBR
 3088/F6B8 : CD DA F1                   	CALL	DEFDMA	;and reset dma address.
 3089/F6BB :                            ;
 3090/F6BB :                            ;   Normal disk write. Set the desired track and sector then
 3091/F6BB :                            ; do the actual write.
 3092/F6BB :                            ;
 3093/F6BB : CD D1 EF                   WTSEQ9	CALL	TRKSEC1	;determine track and sector for this write.
 3094/F6BE : C1                         	POP	B	;get write status flag.
 3095/F6BF : C5                         	PUSH	B
 3096/F6C0 : CD B8 EF                   	CALL	DOWRITE	;and write this out.
 3097/F6C3 : C1                         	POP	B
 3098/F6C4 : 3A E3 F9                   	LDA	SAVNREC	;get number of records in file.
 3099/F6C7 : 21 E1 F9                   	LXI	H,SAVNXT;get last record written.
 3100/F6CA : BE                         	CMP	M
 3101/F6CB : DA D2 F6                   	JC	WTSEQ10
 3102/F6CE : 77                         	MOV	M,A	;we have to update record count.
 3103/F6CF : 34                         	INR	M
 3104/F6D0 : 0E 02                      	MVI	C,2
 3105/F6D2 :                            ;
 3106/F6D2 :                            ;*   This area has been patched to correct disk update problem
 3107/F6D2 :                            ;* when using blocking and de-blocking in the BIOS.
 3108/F6D2 :                            ;
 3109/F6D2 : 00                         WTSEQ10	NOP		;was 'dcr c'
 3110/F6D3 : 00                         	NOP		;was 'dcr c'
 3111/F6D4 : 21 00 00                   	LXI	H,0	;was 'jnz wtseq99'
 3112/F6D7 :                            ;
 3113/F6D7 :                            ; *   End of patch.
 3114/F6D7 :                            ;
 3115/F6D7 : F5                         	PUSH	PSW
 3116/F6D8 : CD 69 F1                   	CALL	GETS2	;set 'extent written to' flag.
 3117/F6DB : E6 7F                      	ANI	7FH	;(* clear bit 7 *)
 3118/F6DD : 77                         	MOV	M,A
 3119/F6DE : F1                         	POP	PSW	;get record count for this extent.
 3120/F6DF : FE 7F                      WTSEQ99	CPI	127	;is it full?
 3121/F6E1 : C2 00 F7                   	JNZ	WTSEQ12
 3122/F6E4 : 3A D5 F9                   	LDA	MODE	;yes, are we in sequential mode?
 3123/F6E7 : FE 01                      	CPI	1
 3124/F6E9 : C2 00 F7                   	JNZ	WTSEQ12
 3125/F6EC : CD D2 F0                   	CALL	SETNREC	;yes, set next record number.
 3126/F6EF : CD 5A F5                   	CALL	GETNEXT	;and get next empty space in directory.
 3127/F6F2 : 21 45 EF                   	LXI	H,STATUS;ok?
 3128/F6F5 : 7E                         	MOV	A,M
 3129/F6F6 : B7                         	ORA	A
 3130/F6F7 : C2 FE F6                   	JNZ	WTSEQ11
 3131/F6FA : 3D                         	DCR	A	;yes, set record count to -1.
 3132/F6FB : 32 E3 F9                   	STA	SAVNREC
 3133/F6FE : 36 00                      WTSEQ11	MVI	M,0	;clear status.
 3134/F700 : C3 D2 F0                   WTSEQ12	JMP	SETNREC	;set next record to access.
 3135/F703 :                            ;
 3136/F703 :                            ;   For random i/o, set the fcb for the desired record number
 3137/F703 :                            ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
 3138/F703 :                            ; used as follows:
 3139/F703 :                            ;
 3140/F703 :                            ;       fcb+35            fcb+34            fcb+33
 3141/F703 :                            ;  |     'r-2'      |      'r-1'      |      'r-0'     |
 3142/F703 :                            ;  |7             0 | 7             0 | 7             0|
 3143/F703 :                            ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
 3144/F703 :                            ;  |    overflow   | | extra |  extent   |   record #  |
 3145/F703 :                            ;  | ______________| |_extent|__number___|_____________|
 3146/F703 :                            ;                     also 's2'
 3147/F703 :                            ;
 3148/F703 :                            ;   On entry, register (C) contains 0ffh if this is a read
 3149/F703 :                            ; and thus we can not access unwritten disk space. Otherwise,
 3150/F703 :                            ; another extent will be opened (for writing) if required.
 3151/F703 :                            ;
 3152/F703 : AF                         POSITION:XRA	A	;set random i/o flag.
 3153/F704 : 32 D5 F9                   	STA	MODE
 3154/F707 :                            ;
 3155/F707 :                            ;   Special entry (function #40). M/PM ?
 3156/F707 :                            ;
 3157/F707 : C5                         POSITN1	PUSH	B	;save read/write flag.
 3158/F708 : 2A 43 EF                   	LHLD	PARAMS	;get address of fcb.
 3159/F70B : EB                         	XCHG
 3160/F70C : 21 21 00                   	LXI	H,33	;now get byte 'r0'.
 3161/F70F : 19                         	DAD	D
 3162/F710 : 7E                         	MOV	A,M
 3163/F711 : E6 7F                      	ANI	7FH	;keep bits 0-6 for the record number to access.
 3164/F713 : F5                         	PUSH	PSW
 3165/F714 : 7E                         	MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
 3166/F715 : 17                         	RAL
 3167/F716 : 23                         	INX	H
 3168/F717 : 7E                         	MOV	A,M
 3169/F718 : 17                         	RAL
 3170/F719 : E6 1F                      	ANI	1FH	;and save this in bits 0-4 of (C).
 3171/F71B : 4F                         	MOV	C,A	;this is the extent byte.
 3172/F71C : 7E                         	MOV	A,M	;now get the extra extent byte.
 3173/F71D : 1F                         	RAR
 3174/F71E : 1F                         	RAR
 3175/F71F : 1F                         	RAR
 3176/F720 : 1F                         	RAR
 3177/F721 : E6 0F                      	ANI	0FH
 3178/F723 : 47                         	MOV	B,A	;and save it in (B).
 3179/F724 : F1                         	POP	PSW	;get record number back to (A).
 3180/F725 : 23                         	INX	H	;check overflow byte 'r2'.
 3181/F726 : 6E                         	MOV	L,M
 3182/F727 : 2C                         	INR	L
 3183/F728 : 2D                         	DCR	L
 3184/F729 : 2E 06                      	MVI	L,6	;prepare for error.
 3185/F72B : C2 8B F7                   	JNZ	POSITN5	;out of disk space error.
 3186/F72E : 21 20 00                   	LXI	H,32	;store record number into fcb.
 3187/F731 : 19                         	DAD	D
 3188/F732 : 77                         	MOV	M,A
 3189/F733 : 21 0C 00                   	LXI	H,12	;and now check the extent byte.
 3190/F736 : 19                         	DAD	D
 3191/F737 : 79                         	MOV	A,C
 3192/F738 : 96                         	SUB	M	;same extent as before?
 3193/F739 : C2 47 F7                   	JNZ	POSITN2
 3194/F73C : 21 0E 00                   	LXI	H,14	;yes, check extra extent byte 's2' also.
 3195/F73F : 19                         	DAD	D
 3196/F740 : 78                         	MOV	A,B
 3197/F741 : 96                         	SUB	M
 3198/F742 : E6 7F                      	ANI	7FH
 3199/F744 : CA 7F F7                   	JZ	POSITN3;same, we are almost done then.
 3200/F747 :                            ;
 3201/F747 :                            ;  Get here when another extent is required.
 3202/F747 :                            ;
 3203/F747 : C5                         POSITN2	PUSH	B
 3204/F748 : D5                         	PUSH	D
 3205/F749 : CD A2 F4                   	CALL	CLOSEIT	;close current extent.
 3206/F74C : D1                         	POP	D
 3207/F74D : C1                         	POP	B
 3208/F74E : 2E 03                      	MVI	L,3	;prepare for error.
 3209/F750 : 3A 45 EF                   	LDA	STATUS
 3210/F753 : 3C                         	INR	A
 3211/F754 : CA 84 F7                   	JZ	POSITN4	;close error.
 3212/F757 : 21 0C 00                   	LXI	H,12	;put desired extent into fcb now.
 3213/F75A : 19                         	DAD	D
 3214/F75B : 71                         	MOV	M,C
 3215/F75C : 21 0E 00                   	LXI	H,14	;and store extra extent byte 's2'.
 3216/F75F : 19                         	DAD	D
 3217/F760 : 70                         	MOV	M,B
 3218/F761 : CD 51 F4                   	CALL	OPENIT	;try and get this extent.
 3219/F764 : 3A 45 EF                   	LDA	STATUS	;was it there?
 3220/F767 : 3C                         	INR	A
 3221/F768 : C2 7F F7                   	JNZ	POSITN3
 3222/F76B : C1                         	POP	B	;no. can we create a new one (writing?).
 3223/F76C : C5                         	PUSH	B
 3224/F76D : 2E 04                      	MVI	L,4	;prepare for error.
 3225/F76F : 0C                         	INR	C
 3226/F770 : CA 84 F7                   	JZ	POSITN4	;nope, reading unwritten space error.
 3227/F773 : CD 24 F5                   	CALL	GETEMPTY;yes we can, try to find space.
 3228/F776 : 2E 05                      	MVI	L,5	;prepare for error.
 3229/F778 : 3A 45 EF                   	LDA	STATUS
 3230/F77B : 3C                         	INR	A
 3231/F77C : CA 84 F7                   	JZ	POSITN4	;out of space?
 3232/F77F :                            ;
 3233/F77F :                            ;   Normal return location. Clear error code and return.
 3234/F77F :                            ;
 3235/F77F : C1                         POSITN3	POP	B	;restore stack.
 3236/F780 : AF                         	XRA	A	;and clear error code byte.
 3237/F781 : C3 01 EF                   	JMP	SETSTAT
 3238/F784 :                            ;
 3239/F784 :                            ;   Error. Set the 's2' byte to indicate this (why?).
 3240/F784 :                            ;
 3241/F784 : E5                         POSITN4	PUSH	H
 3242/F785 : CD 69 F1                   	CALL	GETS2
 3243/F788 : 36 C0                      	MVI	M,0C0H
 3244/F78A : E1                         	POP	H
 3245/F78B :                            ;
 3246/F78B :                            ;   Return with error code (presently in L).
 3247/F78B :                            ;
 3248/F78B : C1                         POSITN5	POP	B
 3249/F78C : 7D                         	MOV	A,L	;get error code.
 3250/F78D : 32 45 EF                   	STA	STATUS
 3251/F790 : C3 78 F1                   	JMP	SETS2B7
 3252/F793 :                            ;
 3253/F793 :                            ;   Read a random record.
 3254/F793 :                            ;
 3255/F793 : 0E FF                      READRAN	MVI	C,0FFH	;set 'read' status.
 3256/F795 : CD 03 F7                   	CALL	POSITION;position the file to proper record.
 3257/F798 : CC C1 F5                   	CZ	RDSEQ1	;and read it as usual (if no errors).
 3258/F79B : C9                         	RET
 3259/F79C :                            ;
 3260/F79C :                            ;   Write to a random record.
 3261/F79C :                            ;
 3262/F79C : 0E 00                      WRITERAN:MVI	C,0	;set 'writing' flag.
 3263/F79E : CD 03 F7                   	CALL	POSITION;position the file to proper record.
 3264/F7A1 : CC 03 F6                   	CZ	WTSEQ1	;and write as usual (if no errors).
 3265/F7A4 : C9                         	RET
 3266/F7A5 :                            ;
 3267/F7A5 :                            ;   Compute the random record number. Enter with (HL) pointing
 3268/F7A5 :                            ; to a fcb an (DE) contains a relative location of a record
 3269/F7A5 :                            ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
 3270/F7A5 :                            ; byte, and (A) the 'r2' byte.
 3271/F7A5 :                            ;
 3272/F7A5 :                            ;   On return, the zero flag is set if the record is within
 3273/F7A5 :                            ; bounds. Otherwise, an overflow occured.
 3274/F7A5 :                            ;
 3275/F7A5 : EB                         COMPRAND:XCHG		;save fcb pointer in (DE).
 3276/F7A6 : 19                         	DAD	D	;compute relative position of record #.
 3277/F7A7 : 4E                         	MOV	C,M	;get record number into (BC).
 3278/F7A8 : 06 00                      	MVI	B,0
 3279/F7AA : 21 0C 00                   	LXI	H,12	;now get extent.
 3280/F7AD : 19                         	DAD	D
 3281/F7AE : 7E                         	MOV	A,M	;compute (BC)=(record #)+(extent)*128.
 3282/F7AF : 0F                         	RRC		;move lower bit into bit 7.
 3283/F7B0 : E6 80                      	ANI	80H	;and ignore all other bits.
 3284/F7B2 : 81                         	ADD	C	;add to our record number.
 3285/F7B3 : 4F                         	MOV	C,A
 3286/F7B4 : 3E 00                      	MVI	A,0	;take care of any carry.
 3287/F7B6 : 88                         	ADC	B
 3288/F7B7 : 47                         	MOV	B,A
 3289/F7B8 : 7E                         	MOV	A,M	;now get the upper bits of extent into
 3290/F7B9 : 0F                         	RRC		;bit positions 0-3.
 3291/F7BA : E6 0F                      	ANI	0FH	;and ignore all others.
 3292/F7BC : 80                         	ADD	B	;add this in to 'r1' byte.
 3293/F7BD : 47                         	MOV	B,A
 3294/F7BE : 21 0E 00                   	LXI	H,14	;get the 's2' byte (extra extent).
 3295/F7C1 : 19                         	DAD	D
 3296/F7C2 : 7E                         	MOV	A,M
 3297/F7C3 : 87                         	ADD	A	;and shift it left 4 bits (bits 4-7).
 3298/F7C4 : 87                         	ADD	A
 3299/F7C5 : 87                         	ADD	A
 3300/F7C6 : 87                         	ADD	A
 3301/F7C7 : F5                         	PUSH	PSW	;save carry flag (bit 0 of flag byte).
 3302/F7C8 : 80                         	ADD	B	;now add extra extent into 'r1'.
 3303/F7C9 : 47                         	MOV	B,A
 3304/F7CA : F5                         	PUSH	PSW	;and save carry (overflow byte 'r2').
 3305/F7CB : E1                         	POP	H	;bit 0 of (L) is the overflow indicator.
 3306/F7CC : 7D                         	MOV	A,L
 3307/F7CD : E1                         	POP	H	;and same for first carry flag.
 3308/F7CE : B5                         	ORA	L	;either one of these set?
 3309/F7CF : E6 01                      	ANI	01H	;only check the carry flags.
 3310/F7D1 : C9                         	RET
 3311/F7D2 :                            ;
 3312/F7D2 :                            ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
 3313/F7D2 :                            ; reflect the last record used for a random (or other) file.
 3314/F7D2 :                            ; This reads the directory and looks at all extents computing
 3315/F7D2 :                            ; the largerst record number for each and keeping the maximum
 3316/F7D2 :                            ; value only. Then 'r0', 'r1', and 'r2' will reflect this
 3317/F7D2 :                            ; maximum record number. This is used to compute the space used
 3318/F7D2 :                            ; by a random file.
 3319/F7D2 :                            ;
 3320/F7D2 : 0E 0C                      RANSIZE	MVI	C,12	;look thru directory for first entry with
 3321/F7D4 : CD 18 F3                   	CALL	FINDFST	;this name.
 3322/F7D7 : 2A 43 EF                   	LHLD	PARAMS	;zero out the 'r0, r1, r2' bytes.
 3323/F7DA : 11 21 00                   	LXI	D,33
 3324/F7DD : 19                         	DAD	D
 3325/F7DE : E5                         	PUSH	H
 3326/F7DF : 72                         	MOV	M,D	;note that (D)=0.
 3327/F7E0 : 23                         	INX	H
 3328/F7E1 : 72                         	MOV	M,D
 3329/F7E2 : 23                         	INX	H
 3330/F7E3 : 72                         	MOV	M,D
 3331/F7E4 : CD F5 F1                   RANSIZ1	CALL	CKFILPOS;is there an extent to process?
 3332/F7E7 : CA 0C F8                   	JZ	RANSIZ3	;no, we are done.
 3333/F7EA : CD 5E F1                   	CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
 3334/F7ED : 11 0F 00                   	LXI	D,15	;point to last record in extent.
 3335/F7F0 : CD A5 F7                   	CALL	COMPRAND;and compute random parameters.
 3336/F7F3 : E1                         	POP	H
 3337/F7F4 : E5                         	PUSH	H	;now check these values against those
 3338/F7F5 : 5F                         	MOV	E,A	;already in fcb.
 3339/F7F6 : 79                         	MOV	A,C	;the carry flag will be set if those
 3340/F7F7 : 96                         	SUB	M	;in the fcb represent a larger size than
 3341/F7F8 : 23                         	INX	H	;this extent does.
 3342/F7F9 : 78                         	MOV	A,B
 3343/F7FA : 9E                         	SBB	M
 3344/F7FB : 23                         	INX	H
 3345/F7FC : 7B                         	MOV	A,E
 3346/F7FD : 9E                         	SBB	M
 3347/F7FE : DA 06 F8                   	JC	RANSIZ2
 3348/F801 : 73                         	MOV	M,E	;we found a larger (in size) extent.
 3349/F802 : 2B                         	DCX	H	;stuff these values into fcb.
 3350/F803 : 70                         	MOV	M,B
 3351/F804 : 2B                         	DCX	H
 3352/F805 : 71                         	MOV	M,C
 3353/F806 : CD 2D F3                   RANSIZ2	CALL	FINDNXT	;now get the next extent.
 3354/F809 : C3 E4 F7                   	JMP	RANSIZ1	;continue til all done.
 3355/F80C : E1                         RANSIZ3	POP	H	;we are done, restore the stack and
 3356/F80D : C9                         	RET		;return.
 3357/F80E :                            ;
 3358/F80E :                            ;   Function to return the random record position of a given
 3359/F80E :                            ; file which has been read in sequential mode up to now.
 3360/F80E :                            ;
 3361/F80E : 2A 43 EF                   SETRAN	LHLD	PARAMS	;point to fcb.
 3362/F811 : 11 20 00                   	LXI	D,32	;and to last used record.
 3363/F814 : CD A5 F7                   	CALL	COMPRAND;compute random position.
 3364/F817 : 21 21 00                   	LXI	H,33	;now stuff these values into fcb.
 3365/F81A : 19                         	DAD	D
 3366/F81B : 71                         	MOV	M,C	;move 'r0'.
 3367/F81C : 23                         	INX	H
 3368/F81D : 70                         	MOV	M,B	;and 'r1'.
 3369/F81E : 23                         	INX	H
 3370/F81F : 77                         	MOV	M,A	;and lastly 'r2'.
 3371/F820 : C9                         	RET
 3372/F821 :                            ;
 3373/F821 :                            ;   This routine select the drive specified in (ACTIVE) and
 3374/F821 :                            ; update the login vector and bitmap table if this drive was
 3375/F821 :                            ; not already active.
 3376/F821 :                            ;
 3377/F821 : 2A AF F9                   LOGINDRV:LHLD	LOGIN	;get the login vector.
 3378/F824 : 3A 42 EF                   	LDA	ACTIVE	;get the default drive.
 3379/F827 : 4F                         	MOV	C,A
 3380/F828 : CD EA F0                   	CALL	SHIFTR	;position active bit for this drive
 3381/F82B : E5                         	PUSH	H	;into bit 0.
 3382/F82C : EB                         	XCHG
 3383/F82D : CD 59 EF                   	CALL	SELECT	;select this drive.
 3384/F830 : E1                         	POP	H
 3385/F831 : CC 47 EF                   	CZ	SLCTERR	;valid drive?
 3386/F834 : 7D                         	MOV	A,L	;is this a newly activated drive?
 3387/F835 : 1F                         	RAR
 3388/F836 : D8                         	RC
 3389/F837 : 2A AF F9                   	LHLD	LOGIN	;yes, update the login vector.
 3390/F83A : 4D                         	MOV	C,L
 3391/F83B : 44                         	MOV	B,H
 3392/F83C : CD 0B F1                   	CALL	SETBIT
 3393/F83F : 22 AF F9                   	SHLD	LOGIN	;and save.
 3394/F842 : C3 A3 F2                   	JMP	BITMAP	;now update the bitmap.
 3395/F845 :                            ;
 3396/F845 :                            ;   Function to set the active disk number.
 3397/F845 :                            ;
 3398/F845 : 3A D6 F9                   SETDSK	LDA	EPARAM	;get parameter passed and see if this
 3399/F848 : 21 42 EF                   	LXI	H,ACTIVE;represents a change in drives.
 3400/F84B : BE                         	CMP	M
 3401/F84C : C8                         	RZ
 3402/F84D : 77                         	MOV	M,A	;yes it does, log it in.
 3403/F84E : C3 21 F8                   	JMP	LOGINDRV
 3404/F851 :                            ;
 3405/F851 :                            ;   This is the 'auto disk select' routine. The firsst byte
 3406/F851 :                            ; of the fcb is examined for a drive specification. If non
 3407/F851 :                            ; zero then the drive will be selected and loged in.
 3408/F851 :                            ;
 3409/F851 : 3E FF                      AUTOSEL	MVI	A,0FFH	;say 'auto-select activated'.
 3410/F853 : 32 DE F9                   	STA	AUTO
 3411/F856 : 2A 43 EF                   	LHLD	PARAMS	;get drive specified.
 3412/F859 : 7E                         	MOV	A,M
 3413/F85A : E6 1F                      	ANI	1FH	;look at lower 5 bits.
 3414/F85C : 3D                         	DCR	A	;adjust for (1=A, 2=B) etc.
 3415/F85D : 32 D6 F9                   	STA	EPARAM	;and save for the select routine.
 3416/F860 : FE 1E                      	CPI	1EH	;check for 'no change' condition.
 3417/F862 : D2 75 F8                   	JNC	AUTOSL1	;yes, don't change.
 3418/F865 : 3A 42 EF                   	LDA	ACTIVE	;we must change, save currently active
 3419/F868 : 32 DF F9                   	STA	OLDDRV	;drive.
 3420/F86B : 7E                         	MOV	A,M	;and save first byte of fcb also.
 3421/F86C : 32 E0 F9                   	STA	AUTOFLAG;this must be non-zero.
 3422/F86F : E6 E0                      	ANI	0E0H	;whats this for (bits 6,7 are used for
 3423/F871 : 77                         	MOV	M,A	;something)?
 3424/F872 : CD 45 F8                   	CALL	SETDSK	;select and log in this drive.
 3425/F875 : 3A 41 EF                   AUTOSL1	LDA	USERNO	;move user number into fcb.
 3426/F878 : 2A 43 EF                   	LHLD	PARAMS	;(* upper half of first byte *)
 3427/F87B : B6                         	ORA	M
 3428/F87C : 77                         	MOV	M,A
 3429/F87D : C9                         	RET		;and return (all done).
 3430/F87E :                            ;
 3431/F87E :                            ;   Function to return the current cp/m version number.
 3432/F87E :                            ;
 3433/F87E : 3E 22                      GETVER	MVI	A,022h	;version 2.2
 3434/F880 : C3 01 EF                   	JMP	SETSTAT
 3435/F883 :                            ;
 3436/F883 :                            ;   Function to reset the disk system.
 3437/F883 :                            ;
 3438/F883 : 21 00 00                   RSTDSK	LXI	H,0	;clear write protect status and log
 3439/F886 : 22 AD F9                   	SHLD	WRTPRT	;in vector.
 3440/F889 : 22 AF F9                   	SHLD	LOGIN
 3441/F88C : AF                         	XRA	A	;select drive 'A'.
 3442/F88D : 32 42 EF                   	STA	ACTIVE
 3443/F890 : 21 80 00                   	LXI	H,TBUFF	;setup default dma address.
 3444/F893 : 22 B1 F9                   	SHLD	USERDMA
 3445/F896 : CD DA F1                   	CALL	DEFDMA
 3446/F899 : C3 21 F8                   	JMP	LOGINDRV;now log in drive 'A'.
 3447/F89C :                            ;
 3448/F89C :                            ;   Function to open a specified file.
 3449/F89C :                            ;
 3450/F89C : CD 72 F1                   OPENFIL	CALL	CLEARS2	;clear 's2' byte.
 3451/F89F : CD 51 F8                   	CALL	AUTOSEL	;select proper disk.
 3452/F8A2 : C3 51 F4                   	JMP	OPENIT	;and open the file.
 3453/F8A5 :                            ;
 3454/F8A5 :                            ;   Function to close a specified file.
 3455/F8A5 :                            ;
 3456/F8A5 : CD 51 F8                   CLOSEFIL:CALL	AUTOSEL	;select proper disk.
 3457/F8A8 : C3 A2 F4                   	JMP	CLOSEIT	;and close the file.
 3458/F8AB :                            ;
 3459/F8AB :                            ;   Function to return the first occurence of a specified file
 3460/F8AB :                            ; name. If the first byte of the fcb is '?' then the name will
 3461/F8AB :                            ; not be checked (get the first entry no matter what).
 3462/F8AB :                            ;
 3463/F8AB : 0E 00                      GETFST	MVI	C,0	;prepare for special search.
 3464/F8AD : EB                         	XCHG
 3465/F8AE : 7E                         	MOV	A,M	;is first byte a '?'?
 3466/F8AF : FE 3F                      	CPI	'?'
 3467/F8B1 : CA C2 F8                   	JZ	GETFST1	;yes, just get very first entry (zero length match).
 3468/F8B4 : CD A6 F0                   	CALL	SETEXT	;get the extension byte from fcb.
 3469/F8B7 : 7E                         	MOV	A,M	;is it '?'? if yes, then we want
 3470/F8B8 : FE 3F                      	CPI	'?'	;an entry with a specific 's2' byte.
 3471/F8BA : C4 72 F1                   	CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
 3472/F8BD : CD 51 F8                   	CALL	AUTOSEL	;select proper drive.
 3473/F8C0 : 0E 0F                      	MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
 3474/F8C2 : CD 18 F3                   GETFST1	CALL	FINDFST	;find an entry and then move it into
 3475/F8C5 : C3 E9 F1                   	JMP	MOVEDIR	;the users dma space.
 3476/F8C8 :                            ;
 3477/F8C8 :                            ;   Function to return the next occurence of a file name.
 3478/F8C8 :                            ;
 3479/F8C8 : 2A D9 F9                   GETNXT	LHLD	SAVEFCB	;restore pointers. note that no
 3480/F8CB : 22 43 EF                   	SHLD	PARAMS	;other dbos calls are allowed.
 3481/F8CE : CD 51 F8                   	CALL	AUTOSEL	;no error will be returned, but the
 3482/F8D1 : CD 2D F3                   	CALL	FINDNXT	;results will be wrong.
 3483/F8D4 : C3 E9 F1                   	JMP	MOVEDIR
 3484/F8D7 :                            ;
 3485/F8D7 :                            ;   Function to delete a file by name.
 3486/F8D7 :                            ;
 3487/F8D7 : CD 51 F8                   DELFILE	CALL	AUTOSEL	;select proper drive.
 3488/F8DA : CD 9C F3                   	CALL	ERAFILE	;erase the file.
 3489/F8DD : C3 01 F3                   	JMP	STSTATUS;set status and return.
 3490/F8E0 :                            ;
 3491/F8E0 :                            ;   Function to execute a sequential read of the specified
 3492/F8E0 :                            ; record number.
 3493/F8E0 :                            ;
 3494/F8E0 : CD 51 F8                   READSEQ	CALL	AUTOSEL	;select proper drive then read.
 3495/F8E3 : C3 BC F5                   	JMP	RDSEQ
 3496/F8E6 :                            ;
 3497/F8E6 :                            ;   Function to write the net sequential record.
 3498/F8E6 :                            ;
 3499/F8E6 : CD 51 F8                   WRTSEQ	CALL	AUTOSEL	;select proper drive then write.
 3500/F8E9 : C3 FE F5                   	JMP	WTSEQ
 3501/F8EC :                            ;
 3502/F8EC :                            ;   Create a file function.
 3503/F8EC :                            ;
 3504/F8EC : CD 72 F1                   FCREATE	CALL	CLEARS2	;clear the 's2' byte on all creates.
 3505/F8EF : CD 51 F8                   	CALL	AUTOSEL	;select proper drive and get the next
 3506/F8F2 : C3 24 F5                   	JMP	GETEMPTY;empty directory space.
 3507/F8F5 :                            ;
 3508/F8F5 :                            ;   Function to rename a file.
 3509/F8F5 :                            ;
 3510/F8F5 : CD 51 F8                   RENFILE	CALL	AUTOSEL	;select proper drive and then switch
 3511/F8F8 : CD 16 F4                   	CALL	CHGNAMES;file names.
 3512/F8FB : C3 01 F3                   	JMP	STSTATUS
 3513/F8FE :                            ;
 3514/F8FE :                            ;   Function to return the login vector.
 3515/F8FE :                            ;
 3516/F8FE : 2A AF F9                   GETLOG	LHLD	LOGIN
 3517/F901 : C3 29 F9                   	JMP	GETPRM1
 3518/F904 :                            ;
 3519/F904 :                            ;   Function to return the current disk assignment.
 3520/F904 :                            ;
 3521/F904 : 3A 42 EF                   GETCRNT	LDA	ACTIVE
 3522/F907 : C3 01 EF                   	JMP	SETSTAT
 3523/F90A :                            ;
 3524/F90A :                            ;   Function to set the dma address.
 3525/F90A :                            ;
 3526/F90A : EB                         PUTDMA	XCHG
 3527/F90B : 22 B1 F9                   	SHLD	USERDMA	;save in our space and then get to
 3528/F90E : C3 DA F1                   	JMP	DEFDMA	;the bios with this also.
 3529/F911 :                            ;
 3530/F911 :                            ;   Function to return the allocation vector.
 3531/F911 :                            ;
 3532/F911 : 2A BF F9                   GETALOC	LHLD	ALOCVECT
 3533/F914 : C3 29 F9                   	JMP	GETPRM1
 3534/F917 :                            ;
 3535/F917 :                            ;   Function to return the read-only status vector.
 3536/F917 :                            ;
 3537/F917 : 2A AD F9                   GETROV	LHLD	WRTPRT
 3538/F91A : C3 29 F9                   	JMP	GETPRM1
 3539/F91D :                            ;
 3540/F91D :                            ;   Function to set the file attributes (read-only, system).
 3541/F91D :                            ;
 3542/F91D : CD 51 F8                   SETATTR	CALL	AUTOSEL	;select proper drive then save attributes.
 3543/F920 : CD 3B F4                   	CALL	SAVEATTR
 3544/F923 : C3 01 F3                   	JMP	STSTATUS
 3545/F926 :                            ;
 3546/F926 :                            ;   Function to return the address of the disk parameter block
 3547/F926 :                            ; for the current drive.
 3548/F926 :                            ;
 3549/F926 : 2A BB F9                   GETPARM	LHLD	DISKPB
 3550/F929 : 22 45 EF                   GETPRM1	SHLD	STATUS
 3551/F92C : C9                         	RET
 3552/F92D :                            ;
 3553/F92D :                            ;   Function to get or set the user number. If (E) was (FF)
 3554/F92D :                            ; then this is a request to return the current user number.
 3555/F92D :                            ; Else set the user number from (E).
 3556/F92D :                            ;
 3557/F92D : 3A D6 F9                   GETUSER	LDA	EPARAM	;get parameter.
 3558/F930 : FE FF                      	CPI	0FFH	;get user number?
 3559/F932 : C2 3B F9                   	JNZ	SETUSER
 3560/F935 : 3A 41 EF                   	LDA	USERNO	;yes, just do it.
 3561/F938 : C3 01 EF                   	JMP	SETSTAT
 3562/F93B : E6 1F                      SETUSER	ANI	1FH	;no, we should set it instead. keep low
 3563/F93D : 32 41 EF                   	STA	USERNO	;bits (0-4) only.
 3564/F940 : C9                         	RET
 3565/F941 :                            ;
 3566/F941 :                            ;   Function to read a random record from a file.
 3567/F941 :                            ;
 3568/F941 : CD 51 F8                   RDRANDOM:CALL	AUTOSEL	;select proper drive and read.
 3569/F944 : C3 93 F7                   	JMP	READRAN
 3570/F947 :                            ;
 3571/F947 :                            ;   Function to compute the file size for random files.
 3572/F947 :                            ;
 3573/F947 : CD 51 F8                   WTRANDOM:CALL	AUTOSEL	;select proper drive and write.
 3574/F94A : C3 9C F7                   	JMP	WRITERAN
 3575/F94D :                            ;
 3576/F94D :                            ;   Function to compute the size of a random file.
 3577/F94D :                            ;
 3578/F94D : CD 51 F8                   FILESIZE:CALL	AUTOSEL	;select proper drive and check file length
 3579/F950 : C3 D2 F7                   	JMP	RANSIZE
 3580/F953 :                            ;
 3581/F953 :                            ;   Function #37. This allows a program to log off any drives.
 3582/F953 :                            ; On entry, set (DE) to contain a word with bits set for those
 3583/F953 :                            ; drives that are to be logged off. The log-in vector and the
 3584/F953 :                            ; write protect vector will be updated. This must be a M/PM
 3585/F953 :                            ; special function.
 3586/F953 :                            ;
 3587/F953 : 2A 43 EF                   LOGOFF	LHLD	PARAMS	;get drives to log off.
 3588/F956 : 7D                         	MOV	A,L	;for each bit that is set, we want
 3589/F957 : 2F                         	CMA		;to clear that bit in (LOGIN)
 3590/F958 : 5F                         	MOV	E,A	;and (WRTPRT).
 3591/F959 : 7C                         	MOV	A,H
 3592/F95A : 2F                         	CMA
 3593/F95B : 2A AF F9                   	LHLD	LOGIN	;reset the login vector.
 3594/F95E : A4                         	ANA	H
 3595/F95F : 57                         	MOV	D,A
 3596/F960 : 7D                         	MOV	A,L
 3597/F961 : A3                         	ANA	E
 3598/F962 : 5F                         	MOV	E,A
 3599/F963 : 2A AD F9                   	LHLD	WRTPRT
 3600/F966 : EB                         	XCHG
 3601/F967 : 22 AF F9                   	SHLD	LOGIN	;and save.
 3602/F96A : 7D                         	MOV	A,L	;now do the write protect vector.
 3603/F96B : A3                         	ANA	E
 3604/F96C : 6F                         	MOV	L,A
 3605/F96D : 7C                         	MOV	A,H
 3606/F96E : A2                         	ANA	D
 3607/F96F : 67                         	MOV	H,A
 3608/F970 : 22 AD F9                   	SHLD	WRTPRT	;and save. all done.
 3609/F973 : C9                         	RET
 3610/F974 :                            ;
 3611/F974 :                            ;   Get here to return to the user.
 3612/F974 :                            ;
 3613/F974 : 3A DE F9                   GOBACK	LDA	AUTO	;was auto select activated?
 3614/F977 : B7                         	ORA	A
 3615/F978 : CA 91 F9                   	JZ	GOBACK1
 3616/F97B : 2A 43 EF                   	LHLD	PARAMS	;yes, but was a change made?
 3617/F97E : 36 00                      	MVI	M,0	;(* reset first byte of fcb *)
 3618/F980 : 3A E0 F9                   	LDA	AUTOFLAG
 3619/F983 : B7                         	ORA	A
 3620/F984 : CA 91 F9                   	JZ	GOBACK1
 3621/F987 : 77                         	MOV	M,A	;yes, reset first byte properly.
 3622/F988 : 3A DF F9                   	LDA	OLDDRV	;and get the old drive and select it.
 3623/F98B : 32 D6 F9                   	STA	EPARAM
 3624/F98E : CD 45 F8                   	CALL	SETDSK
 3625/F991 : 2A 0F EF                   GOBACK1	LHLD	USRSTACK;reset the users stack pointer.
 3626/F994 : F9                         	SPHL
 3627/F995 : 2A 45 EF                   	LHLD	STATUS	;get return status.
 3628/F998 : 7D                         	MOV	A,L	;force version 1.4 compatability.
 3629/F999 : 44                         	MOV	B,H
 3630/F99A : C9                         	RET		;and go back to user.
 3631/F99B :                            ;
 3632/F99B :                            ;   Function #40. This is a special entry to do random i/o.
 3633/F99B :                            ; For the case where we are writing to unused disk space, this
 3634/F99B :                            ; space will be zeroed out first. This must be a M/PM special
 3635/F99B :                            ; purpose function, because why would any normal program even
 3636/F99B :                            ; care about the previous contents of a sector about to be
 3637/F99B :                            ; written over.
 3638/F99B :                            ;
 3639/F99B : CD 51 F8                   WTSPECL	CALL	AUTOSEL	;select proper drive.
 3640/F99E : 3E 02                      	MVI	A,2	;use special write mode.
 3641/F9A0 : 32 D5 F9                   	STA	MODE
 3642/F9A3 : 0E 00                      	MVI	C,0	;set write indicator.
 3643/F9A5 : CD 07 F7                   	CALL	POSITN1	;position the file.
 3644/F9A8 : CC 03 F6                   	CZ	WTSEQ1	;and write (if no errors).
 3645/F9AB : C9                         	RET
 3646/F9AC :                            ;
 3647/F9AC :                            ;**************************************************************
 3648/F9AC :                            ;*
 3649/F9AC :                            ;*     BDOS data storage pool.
 3650/F9AC :                            ;*
 3651/F9AC :                            ;**************************************************************
 3652/F9AC :                            ;
 3653/F9AC : E5                         EMPTYFCB:DB	0E5H	;empty directory segment indicator.
 3654/F9AD : 00 00                      WRTPRT	DW	0	;write protect status for all 16 drives.
 3655/F9AF : 00 00                      LOGIN	DW	0	;drive active word (1 bit per drive).
 3656/F9B1 : 80 00                      USERDMA	DW	080H	;user's dma address (defaults to 80h).
 3657/F9B3 :                            ;
 3658/F9B3 :                            ;   Scratch areas from parameter block.
 3659/F9B3 :                            ;
 3660/F9B3 : 00 00                      SCRATCH1:DW	0	;relative position within dir segment for file (0-3).
 3661/F9B5 : 00 00                      SCRATCH2:DW	0	;last selected track number.
 3662/F9B7 : 00 00                      SCRATCH3:DW	0	;last selected sector number.
 3663/F9B9 :                            ;
 3664/F9B9 :                            ;   Disk storage areas from parameter block.
 3665/F9B9 :                            ;
 3666/F9B9 : 00 00                      DIRBUF	DW	0	;address of directory buffer to use.
 3667/F9BB : 00 00                      DISKPB	DW	0	;contains address of disk parameter block.
 3668/F9BD : 00 00                      CHKVECT	DW	0	;address of check vector.
 3669/F9BF : 00 00                      ALOCVECT:DW	0	;address of allocation vector (bit map).
 3670/F9C1 :                            ;
 3671/F9C1 :                            ;   Parameter block returned from the bios.
 3672/F9C1 :                            ;
 3673/F9C1 : 00 00                      SECTORS	DW	0	;sectors per track from bios.
 3674/F9C3 : 00                         BLKSHFT	DB	0	;block shift.
 3675/F9C4 : 00                         BLKMASK	DB	0	;block mask.
 3676/F9C5 : 00                         EXTMASK	DB	0	;extent mask.
 3677/F9C6 : 00 00                      DSKSIZE	DW	0	;disk size from bios (number of blocks-1).
 3678/F9C8 : 00 00                      DIRSIZE	DW	0	;directory size.
 3679/F9CA : 00 00                      ALLOC0	DW	0	;storage for first bytes of bit map (dir space used).
 3680/F9CC : 00 00                      ALLOC1	DW	0
 3681/F9CE : 00 00                      OFFSET	DW	0	;first usable track number.
 3682/F9D0 : 00 00                      XLATE	DW	0	;sector translation table address.
 3683/F9D2 :                            ;
 3684/F9D2 :                            ;
 3685/F9D2 : 00                         CLOSEFLG:DB	0	;close flag (=0ffh is extent written ok).
 3686/F9D3 : 00                         RDWRTFLG:DB	0	;read/write flag (0ffh=read, 0=write).
 3687/F9D4 : 00                         FNDSTAT	DB	0	;filename found status (0=found first entry).
 3688/F9D5 : 00                         MODE	DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
 3689/F9D6 : 00                         EPARAM	DB	0	;storage for register (E) on entry to bdos.
 3690/F9D7 : 00                         RELBLOCK:DB	0	;relative position within fcb of block number written.
 3691/F9D8 : 00                         COUNTER	DB	0	;byte counter for directory name searches.
 3692/F9D9 : 00 00 00 00                SAVEFCB	DW	0,0	;save space for address of fcb (for directory searches).
 3693/F9DD : 00                         BIGDISK	DB	0	;if =0 then disk is > 256 blocks long.
 3694/F9DE : 00                         AUTO	DB	0	;if non-zero, then auto select activated.
 3695/F9DF : 00                         OLDDRV	DB	0	;on auto select, storage for previous drive.
 3696/F9E0 : 00                         AUTOFLAG:DB	0	;if non-zero, then auto select changed drives.
 3697/F9E1 : 00                         SAVNXT	DB	0	;storage for next record number to access.
 3698/F9E2 : 00                         SAVEXT	DB	0	;storage for extent number of file.
 3699/F9E3 : 00 00                      SAVNREC	DW	0	;storage for number of records in file.
 3700/F9E5 : 00 00                      BLKNMBR	DW	0	;block number (physical sector) used within a file or logical sector.
 3701/F9E7 : 00 00                      LOGSECT	DW	0	;starting logical (128 byte) sector of block (physical sector).
 3702/F9E9 : 00                         FCBPOS	DB	0	;relative position within buffer for fcb of file of interest.
 3703/F9EA : 00 00                      FILEPOS	DW	0	;files position within directory (0 to max entries -1).
 3704/F9EC :                            ;
 3705/F9EC :                            ;   Disk directory buffer checksum bytes. One for each of the
 3706/F9EC :                            ; 16 possible drives.
 3707/F9EC :                            ;
 3708/F9EC : 00 00 00 00 00 00 00 00 00 CKSUMTBL:DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
      F9F5 : 00 00 00 00 00 00 00      
 3709/F9FC :                            ;
 3710/F9FC :                            ;   Extra space ?
 3711/F9FC :                            ;
 3712/F9FC : 00 00 00 00                	DB	0,0,0,0
 3713/FA00 :                            ;
 3714/FA00 :                            ;**************************************************************
 3715/FA00 :                            ;*
 3716/FA00 :                            ;*        B I O S   J U M P   T A B L E
 3717/FA00 :                            ;*
 3718/FA00 :                            ;**************************************************************
 3719/FA00 :                            ;
 3720/FA00 : C3 00 00                   BOOT	JMP	0	;NOTE WE USE FAKE DESTINATIONS
 3721/FA03 : C3 00 00                   WBOOT	JMP	0
 3722/FA06 : C3 00 00                   CONST	JMP	0
 3723/FA09 : C3 00 00                   CONIN	JMP	0
 3724/FA0C : C3 00 00                   CONOUT	JMP	0
 3725/FA0F : C3 00 00                   LIST	JMP	0
 3726/FA12 : C3 00 00                   PUNCH	JMP	0
 3727/FA15 : C3 00 00                   READER	JMP	0
 3728/FA18 : C3 00 00                   HOME	JMP	0
 3729/FA1B : C3 00 00                   SELDSK	JMP	0
 3730/FA1E : C3 00 00                   SETTRK	JMP	0
 3731/FA21 : C3 00 00                   SETSEC	JMP	0
 3732/FA24 : C3 00 00                   SETDMA	JMP	0
 3733/FA27 : C3 00 00                   READ	JMP	0
 3734/FA2A : C3 00 00                   WRITE	JMP	0
 3735/FA2D : C3 00 00                   PRSTAT	JMP	0
 3736/FA30 : C3 00 00                   SECTRN	JMP	0
 3737/FA33 :                            ;
 3738/FA33 :                            ;*
 3739/FA33 :                            ;******************   E N D   O F   C P / M   *****************
 3740/FA33 :                            ;*
 3741/FA33 :                            
 3742/FA33 :                            
 AS V1.42 Beta [Bld 271] - Source File CPM22_CCP_BDOS.asm - Page 2 - 7/13/2024 12:6:36


  Symbol Table (* = unused):
  --------------------------

 ACTIVE :                     0EF42 C |  ADDA2HL :                    0F164 C |
 ADDHL :                      0E659 C |  ALLOC0 :                     0F9CA C |
 ALLOC1 :                     0F9CC C |  ALOCVECT :                   0F9BF C |
*ARCHITECTURE :                                        "i386-unknown-win32" - |
 AUTO :                       0F9DE C |  AUTOFLAG :                   0F9E0 C |
 AUTOSEL :                    0F851 C |  AUTOSL1 :                    0F875 C |
 BACKUP :                     0EDA4 C |  BACKUP1 :                    0EDAC C |
 BADLOAD :                    0EB7A C |  BADSCTR :                    0EC09 C |
 BADSEC :                     0ECCA C |  BADSEL :                     0ECD5 C |
 BADSLCT :                    0EC0B C |  BATCH :                      0EBAB C |
 BATCHFCB :                   0EBAC C |  BDOSDRV :                    0ECC6 C |
 BDOSERR :                    0ECBA C |  BIGDISK :                    0F9DD C |
 BITMAP :                     0F2A3 C |  BITMAP1 :                    0F2B1 C |
 BITMAP2 :                    0F2D2 C |  BITMAP3 :                    0F2F6 C |
 BLKMASK :                    0F9C4 C |  BLKNMBR :                    0F9E5 C |
 BLKSHFT :                    0F9C3 C | *BOOT :                       0FA00 C |
 BS :                             8 - | *CASESENSITIVE :                  0 - |
 CBASE :                      0E400 C |  CCPSTACK :                   0EBAB - |
 CDRIVE :                     0EBEF C |  CHARBUF :                    0EF0E C |
 CHECK :                      0E630 C |  CHECKDIR :                   0F19E C |
 CHECKSUM :                   0F0F7 C |  CHGDRV :                     0EBF0 C |
 CHGNAM1 :                    0F427 C |  CHGNAMES :                   0F416 C |
 CHKBLK :                     0F084 C |  CHKCHAR :                    0ED14 C |
 CHKCON :                     0E5C2 C |  CHKDIR1 :                    0F1C4 C |
 CHKNMBR :                    0F18C C |  CHKROFL :                    0F144 C |
 CHKSUM1 :                    0F0FD C |  CHKVECT :                    0F9BD C |
 CHKWPRT :                    0F154 C |  CKBITMAP :                   0F235 C |
 CKBMAP1 :                    0F256 C |  CKCON1 :                     0ED42 C |
 CKCON2 :                     0ED45 C |  CKCONSOL :                   0ED23 C |
 CKFILPOS :                   0F1F5 C |  CKROF1 :                     0F147 C |
 CKSUMTBL :                   0F9EC C |  CLEARBUF :                   0E758 C |
 CLEARS2 :                    0F172 C |  CLOSE :                      0E4DA C |
 CLOSEFIL :                   0F8A5 C |  CLOSEFLG :                   0F9D2 C |
 CLOSEIT :                    0F4A2 C |  CLOSEIT1 :                   0F4CD C |
 CLOSEIT2 :                   0F4DB C |  CLOSEIT3 :                   0F4E1 C |
 CLOSEIT4 :                   0F4E8 C |  CLOSEIT5 :                   0F4FD C |
 CLOSEIT6 :                   0F517 C |  CLOSEIT7 :                   0F51F C |
 CMDADR :                     0E7C1 C |  CMDTBL :                     0E710 C |
 CMMND1 :                     0E782 C |  CMMND2 :                     0E798 C |
 CNTRLC :                         3 - |  CNTRLE :                         5 - |
 CNTRLP :                        10 - |  CNTRLR :                        12 - |
 CNTRLS :                        13 - |  CNTRLU :                        15 - |
 CNTRLX :                        18 - |  CNTRLZ :                        1A - |
 COMBLK :                     0F077 C |  COMFILE :                    0EB83 C |
 COMMAND :                    0E75C C |  COMPRAND :                   0F7A5 C |
 CONIN :                      0FA09 C |  CONOUT :                     0FA0C C |
 CONST :                      0FA06 C | *CONSTPI :        3.141592653589793 - |
 CONVERT :                    0E660 C |  CONVFST :                    0E65E C |
 CONVRT1 :                    0E689 C |  CONVRT2 :                    0E690 C |
 CONVRT3 :                    0E696 C |  CONVRT4 :                    0E698 C |
 CONVRT5 :                    0E6A9 C |  CONVRT6 :                    0E6AB C |
 CONVRT7 :                    0E6AF C |  CONVRT8 :                    0E6B9 C |
 COUNTER :                    0F9D8 C |  CR :                            0D - |
 CREATE :                     0E509 C |  CRLF :                       0E498 C |
 CURPOS :                     0EF0C C | *DATE :                 "7/13/2024" - |
 DE2HL :                      0EF4F C |  DE2HL1 :                     0EF50 C |
 DECODE :                     0E7F8 C |  DECODE1 :                    0E808 C |
*DECODE2 :                    0E82A C |  DECODE3 :                    0E833 C |
*DECODE4 :                    0E83A C |  DEFDMA :                     0F1DA C |
 DEL :                           7F - |  DELBATCH :                   0E5DD C |
 DELETE :                     0E4EF C |  DELFILE :                    0F8D7 C |
 DIRBUF :                     0F9B9 C |  DIRC1 :                      0EEE0 C |
 DIRCIO :                     0EED4 C |  DIRDMA :                     0F1E0 C |
 DIRDMA1 :                    0F1E3 C |  DIRECT :                     0E877 C |
 DIRECT1 :                    0E888 C |  DIRECT2 :                    0E88F C |
 DIRECT3 :                    0E898 C |  DIRECT4 :                    0E8CC C |
 DIRECT5 :                    0E8D4 C |  DIRECT6 :                    0E8D9 C |
 DIRECT7 :                    0E90E C |  DIRECT8 :                    0E90F C |
 DIRECT9 :                    0E91B C |  DIRREAD :                    0F1D4 C |
 DIRSIZE :                    0F9C8 C |  DIRWRITE :                   0F1C6 C |
 DISKPB :                     0F9BB C |  DISKRO :                     0ECE1 C |
 DMASET :                     0E5D8 C |  DOREAD :                     0EFB2 C |
 DOWRITE :                    0EFB8 C |  DRECT63 :                    0E8F7 C |
 DRECT65 :                    0E8F9 C |  DSELECT :                    0E854 C |
 DSKSEL :                     0E4BD C |  DSKSIZE :                    0F9C6 C |
 EMPTYFCB :                   0F9AC C |  ENTRY :                          5 - |
 ENTRY1 :                     0E4C3 C |  ENTRY2 :                     0E4F4 C |
 EPARAM :                     0F9D6 C |  ERAFIL1 :                    0F3A4 C |
 ERAFILE :                    0F39C C |  ERASE :                      0E91F C |
 ERASE1 :                     0E942 C |  ERROR1 :                     0EC99 C |
 ERROR2 :                     0ECA5 C |  ERROR3 :                     0ECAB C |
 ERROR4 :                     0ECB1 C |  ERROR5 :                     0ECB4 C |
 EXISTS :                     0EA82 C |  EXTBLK :                     0F05E C |
 EXTBLK1 :                    0F071 C |  EXTMASK :                    0F9C5 C |
 EXTRACT :                    0E84B C | *FALSE :                          0 - |
*FBASE :                      0EC06 C |  FBASE1 :                     0EC11 C |
 FCB :                        0EBCD C |  FCB2HL :                     0F15E C |
 FCBPOS :                     0F9E9 C |  FCBSET :                     0F3FD C |
 FCREATE :                    0F8EC C | *FF :                            0C - |
 FILEPOS :                    0F9EA C |  FILERO :                     0ECDC C |
 FILESIZE :                   0F94D C |  FINDFST :                    0F318 C |
 FINDNXT :                    0F32D C |  FNDNXT1 :                    0F34A C |
 FNDNXT2 :                    0F353 C |  FNDNXT3 :                    0F373 C |
 FNDNXT4 :                    0F37C C |  FNDNXT5 :                    0F383 C |
 FNDNXT6 :                    0F394 C |  FNDSPA1 :                    0F3C0 C |
 FNDSPA2 :                    0F3D1 C |  FNDSPA3 :                    0F3EC C |
 FNDSPA4 :                    0F3F4 C |  FNDSPACE :                   0F3BE C |
 FNDSTAT :                    0F9D4 C |  FUNCTNS :                    0EC47 C |
 GETALOC :                    0F911 C |  GETBACK :                    0EB86 C |
 GETBACK1 :                   0EB89 C |  GETBLK1 :                    0F045 C |
 GETBLK2 :                    0F053 C |  GETBLK3 :                    0F05C C |
 GETBLOCK :                   0F03E C |  GETCHAR :                    0ECFB C |
 GETCON :                     0EEC8 C |  GETCRNT :                    0F904 C |
 GETCSTS :                    0EEFE C |  GETDSK :                     0E5D0 C |
 GETECHO :                    0ED06 C |  GETEMPTY :                   0F524 C |
 GETEXT :                     0E6C0 C |  GETEXT1 :                    0E6C8 C |
 GETEXT2 :                    0E6D9 C |  GETEXT3 :                    0E6DB C |
 GETEXT4 :                    0E6DF C |  GETEXT5 :                    0E6E9 C |
 GETEXT6 :                    0E6F0 C |  GETEXT7 :                    0E6F2 C |
 GETEXT8 :                    0E701 C |  GETEXT9 :                    0E709 C |
 GETFST :                     0F8AB C |  GETFST1 :                    0F8C2 C |
 GETINP :                     0E539 C |  GETINP1 :                    0E596 C |
 GETINP2 :                    0E5A7 C |  GETINP3 :                    0E5AB C |
 GETINP4 :                    0E5BA C |  GETIOB :                     0EEED C |
 GETLOG :                     0F8FE C |  GETMT1 :                     0F546 C |
 GETNEXT :                    0F55A C |  GETNXT :                     0F8C8 C |
 GETPARM :                    0F926 C |  GETPRM1 :                    0F929 C |
 GETRDR :                     0EECE C |  GETROV :                     0F917 C |
 GETS2 :                      0F169 C |  GETSETUC :                   0E515 C |
 GETUSER :                    0F92D C |  GETUSR :                     0E513 C |
 GETVER :                     0F87E C |  GETWPRT :                    0F11E C |
 GOBACK :                     0F974 C |  GOBACK1 :                    0F991 C |
 GTNEXT1 :                    0F583 C |  GTNEXT2 :                    0F58E C |
 GTNEXT3 :                    0F5AC C |  GTNEXT4 :                    0F5AF C |
 GTNEXT5 :                    0F5B6 C |  HALT :                       0E7CF C |
*HAS64 :                          0 - |  HL2DE :                      0E842 C |
 HOME :                       0FA18 C |  HOMEDRV :                    0EFA1 C |
 INBUFF :                     0E406 C |  INPOINT :                    0E488 C |
 IOBYTE :                         3 - |  IOERR1 :                     0EF05 C |
 IORET :                      0EFBB C |  JUMPHL :                     0EF4A C |
 LF :                            0A - |  LIST :                       0FA0F C |
*LISTON :                         1 - |  LOGICAL :                    0F08A C |
 LOGICL1 :                    0F090 C |  LOGIN :                      0F9AF C |
 LOGINDRV :                   0F821 C |  LOGOFF :                     0F953 C |
 LOGSECT :                    0F9E7 C | *MACEXP :                         7 - |
 MEM :                           40 - |  MODE :                       0F9D5 C |
*MOMCPU :                      8080 - | *MOMCPUNAME :                "8080" - |
 MOREFLS :                    0F17F C |  MOVE3 :                      0E840 C |
 MOVECD :                     0E529 C |  MOVEDIR :                    0F1E9 C |
 MOVEWORD :                   0F494 C |  NAMEPNT :                    0E48A C |
 NBYTES :                     0EBF1 C | *NESTMAX :                      100 - |
 NEWLINE :                    0EDB1 C |  NEWLN1 :                     0EDB9 C |
 NFUNCTS :                       29 - |  NOFILE :                     0E7F0 C |
 NONBLANK :                   0E64F C |  NONE :                       0E7EA C |
 NOSPACE :                    0EA07 C |  NUMCMDS :                        6 - |
 NXENT1 :                     0F219 C |  NXENT2 :                     0F220 C |
 NXENTRY :                    0F205 C |  OFFSET :                     0F9CE C |
 OLDDRV :                     0F9DF C |  OPEN :                       0E4CB C |
 OPENFCB :                    0E4D0 C |  OPENFIL :                    0F89C C |
 OPENIT :                     0F451 C |  OPENIT1 :                    0F45A C |
 OPENIT2 :                    0F48B C |  OUTCHAR :                    0ED48 C |
 OUTCHR1 :                    0ED62 C |  OUTCHR2 :                    0ED79 C |
 OUTCON :                     0ED90 C |  OUTCON1 :                    0ED96 C |
 OUTCRLF :                    0EDC9 C |  OUTFLAG :                    0EF0A C |
 PARAMS :                     0EF43 C |  PATTRN1 :                    0E728 C |
 PATTRN2 :                    0EC00 C |  PLINE :                      0E4A7 C |
 PLINE2 :                     0E4AC C |  POSITION :                   0F703 C |
 POSITN1 :                    0F707 C |  POSITN2 :                    0F747 C |
 POSITN3 :                    0F77F C |  POSITN4 :                    0F784 C |
 POSITN5 :                    0F78B C |  PRINT :                      0E48C C |
 PRINTB :                     0E492 C | *PRSTAT :                     0FA2D C |
 PRTERR :                     0ECE5 C |  PRTFLAG :                    0EF0D C |
 PRTMESG :                    0EDD3 C |  PRTSTR :                     0EEF8 C |
 PUNCH :                      0FA12 C |  PUTDMA :                     0F90A C |
 RANSIZ1 :                    0F7E4 C |  RANSIZ2 :                    0F806 C |
 RANSIZ3 :                    0F80C C |  RANSIZE :                    0F7D2 C |
 RDBUF1 :                     0EDEF C |  RDBUF10 :                    0EE70 C |
 RDBUF11 :                    0EE78 C |  RDBUF12 :                    0EE8A C |
 RDBUF13 :                    0EE99 C |  RDBUF14 :                    0EEA6 C |
 RDBUF15 :                    0EEA9 C |  RDBUF16 :                    0EEBD C |
 RDBUF17 :                    0EEC1 C |  RDBUF2 :                     0EDF1 C |
 RDBUF3 :                     0EE16 C |  RDBUF4 :                     0EE26 C |
 RDBUF5 :                     0EE37 C |  RDBUF6 :                     0EE48 C |
 RDBUF7 :                     0EE4E C |  RDBUF8 :                     0EE5F C |
 RDBUF9 :                     0EE6B C |  RDBUFF :                     0EDE1 C |
 RDERR :                      0E7DF C |  RDERROR :                    0E7D9 C |
 RDRANDOM :                   0F941 C |  RDREC :                      0E4F9 C |
 RDSEQ :                      0F5BC C |  RDSEQ1 :                     0F5C1 C |
 RDSEQ2 :                     0F5E6 C |  RDSEQ3 :                     0F5FB C |
 RDWRTFLG :                   0F9D3 C |  READ :                       0FA27 C |
 READER :                     0FA15 C |  READFCB :                    0E4FE C |
 READRAN :                    0F793 C |  READSEQ :                    0F8E0 C |
*RELAXED :                        0 - |  RELBLOCK :                   0F9D7 C |
 RENAM :                      0E50E C |  RENAME :                     0EA10 C |
 RENAME1 :                    0EA3F C |  RENAME2 :                    0EA59 C |
*RENAME3 :                    0EA5E C |  RENAME4 :                    0EA6D C |
 RENAME5 :                    0EA73 C |  RENAME6 :                    0EA79 C |
 RENFILE :                    0F8F5 C |  RESDSK :                     0E4B8 C |
 RESETDR :                    0E866 C |  RODISK :                     0EC0D C |
 ROFILE :                     0EC0F C |  RSTDSK :                     0F883 C |
 RTN :                        0EF04 C |  RTNCODE :                    0EBEE C |
 SAMEXT :                     0F307 C |  SAVATR1 :                    0F440 C |
 SAVE :                       0E9AD C |  SAVE1 :                      0E9D4 C |
 SAVE2 :                      0E9F1 C |  SAVE3 :                      0E9FB C |
 SAVE4 :                      0EA01 C |  SAVEATTR :                   0F43B C |
 SAVEFCB :                    0F9D9 C |  SAVEXT :                     0F9E2 C |
 SAVNREC :                    0F9E3 C |  SAVNXT :                     0F9E1 C |
 SCRATCH1 :                   0F9B3 C |  SCRATCH2 :                   0F9B5 C |
 SCRATCH3 :                   0F9B7 C |  SEARCH :                     0E72E C |
 SEARCH1 :                    0E733 C |  SEARCH2 :                    0E73C C |
 SEARCH3 :                    0E74F C |  SEARCH4 :                    0E754 C |
 SECTORS :                    0F9C1 C |  SECTRN :                     0FA30 C |
 SELDSK :                     0FA1B C |  SELECT :                     0EF59 C |
 SELECT1 :                    0EF9D C |  SETATTR :                    0F91D C |
 SETBIT :                     0F10B C |  SETCDRV :                    0E51A C |
 SETDIR :                     0F19C C |  SETDMA :                     0FA24 C |
 SETDSK :                     0F845 C |  SETEXT :                     0F0A6 C |
 SETFILE :                    0F26B C |  SETFL1 :                     0F275 C |
 SETFL2 :                     0F288 C |  SETFL3 :                     0F28E C |
 SETFL4 :                     0F29D C |  SETHLDE :                    0F0AE C |
 SETIOB :                     0EEF3 C |  SETNREC :                    0F0D2 C |
 SETRAN :                     0F80E C |  SETS2B7 :                    0F178 C |
 SETSEC :                     0FA21 C |  SETSTAT :                    0EF01 C |
 SETTRK :                     0FA1E C |  SETUSER :                    0F93B C |
 SHIFTL :                     0F104 C |  SHIFTL1 :                    0F105 C |
 SHIFTR :                     0F0EA C |  SHIFTR1 :                    0F0EB C |
 SHOWIT :                     0ED7F C |  SLCTERR :                    0EF47 C |
 SPACE :                      0E4A2 C |  SRCHFCB :                    0E4E9 C |
 SRCHFST :                    0E4DF C |  SRCHNXT :                    0E4E4 C |
 STARTING :                   0EF0B C |  STATUS :                     0EF45 C |
 STBITMAP :                   0F25C C |  STBMAP1 :                    0F264 C |
 STDDMA :                     0E5D5 C |  STFILPOS :                   0F1FE C |
 STKAREA :                    0EF41 - |  STNREC1 :                    0F0DE C |
 STRDATA :                    0F0BB C |  STSTATUS :                   0F301 C |
 SUBHL :                      0F195 C |  SYNERR :                     0E609 C |
 SYNERR1 :                    0E60F C |  SYNERR2 :                    0E622 C |
 TAB :                            9 - |  TBASE :                        100 - |
 TBUFF :                         80 - |  TDRIVE :                         4 - |
 TFCB :                          5C - | *TIME :                   "12:6:36" - |
 TRKSEC :                     0EFC3 C |  TRKSEC1 :                    0EFD1 C |
 TRKSEC2 :                    0EFE4 C |  TRKSEC3 :                    0EFFA C |
 TRKSEC4 :                    0F00F C | *TRUE :                           1 - |
 TYPE :                       0E95D C |  TYPE1 :                      0E974 C |
*TYPE2 :                      0E977 C |  TYPE3 :                      0E987 C |
 TYPE4 :                      0E9A0 C |  TYPE5 :                      0E9A7 C |
 UNKNOWN :                    0EAA5 C |  UNKWN0 :                     0EB71 C |
 UNKWN1 :                     0EAC4 C | *UNKWN2 :                     0EACD C |
 UNKWN3 :                     0EAE1 C |  UNKWN4 :                     0EB01 C |
 UNKWN5 :                     0EB30 C |  UNKWN6 :                     0EB3E C |
 UNKWN7 :                     0EB43 C |  UNKWN8 :                     0EB4F C |
 UNKWN9 :                     0EB6B C |  UPDATE :                     0F401 C |
 UPDATE1 :                    0F410 C |  UPPER :                      0E530 C |
 USER :                       0EA8E C |  USERDMA :                    0F9B1 C |
 USERNO :                     0EF41 C |  USRSTACK :                   0EF0F C |
 VERIFY :                     0E5F5 C |  VERIFY1 :                    0E5FD C |
*VERSION :                     142F - |  WBOOT :                      0FA03 C |
 WRITE :                      0FA2A C |  WRITERAN :                   0F79C C |
 WRTPRT :                     0F9AD C |  WRTPRTD :                    0F12C C |
 WRTREC :                     0E504 C |  WRTSEQ :                     0F8E6 C |
 WTRANDOM :                   0F947 C |  WTSEQ :                      0F5FE C |
 WTSEQ1 :                     0F603 C |  WTSEQ10 :                    0F6D2 C |
 WTSEQ11 :                    0F6FE C |  WTSEQ12 :                    0F700 C |
 WTSEQ2 :                     0F63B C |  WTSEQ3 :                     0F648 C |
 WTSEQ4 :                     0F664 C |  WTSEQ5 :                     0F66C C |
 WTSEQ6 :                     0F66E C |  WTSEQ7 :                     0F68C C |
 WTSEQ8 :                     0F69A C |  WTSEQ9 :                     0F6BB C |
*WTSEQ99 :                    0F6DF C |  WTSPECL :                    0F99B C |
 XLATE :                      0F9D0 C |  YESNO :                      0E952 C |
*Z80SYNTAX :                      0 - |

    516 symbols
     26 unused symbols

 AS V1.42 Beta [Bld 271] - Source File CPM22_CCP_BDOS.asm - Page 3 - 7/13/2024 12:6:36


  Code Pages:
  ----------

STANDARD (0 changed characters)

1 code page

0.10 seconds assembly time

   3742 lines source file
      2 passes
      0 errors
      0 warnings
